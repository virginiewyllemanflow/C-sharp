{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is C C# is a modern, object-oriented programming language developed by Microsoft as part of its .NET initiative. It is designed for building a wide range of applications, from web to mobile to Windows desktop, and integrates seamlessly with the .NET Framework. C# emphasizes simplicity, robustness, and productivity, making it a popular choice for developers. Note: This documentation was written based on the codeacademy C# course. What is C# What is C# used for? Characteristics of C# Conventions in C# How to run C# code What is C# used for? C# is used to make interactive websites, mobile apps, video games, augmented and virtual reality (AR and VR), back-end services, and desktop applications. Characteristics of C strongly typed (requires you to specify data types) statically typed (will check the correct types have been used before running the program) object-oriented programming language (compiled) runs on .NET framework Conventions in C use camelCase for variables use PascalCase for methods and classes use only letters, underscores, and digits in variable names every statement ends with a semicolon ( ; ) some keywords are reserved and should not be used as variable names e.g. return , break , out , continue ... How to run C# code command in terminal = dotnet run","title":"Home"},{"location":"#what-is-c","text":"C# is a modern, object-oriented programming language developed by Microsoft as part of its .NET initiative. It is designed for building a wide range of applications, from web to mobile to Windows desktop, and integrates seamlessly with the .NET Framework. C# emphasizes simplicity, robustness, and productivity, making it a popular choice for developers. Note: This documentation was written based on the codeacademy C# course. What is C# What is C# used for? Characteristics of C# Conventions in C# How to run C# code","title":"What is C"},{"location":"#what-is-c-used-for","text":"C# is used to make interactive websites, mobile apps, video games, augmented and virtual reality (AR and VR), back-end services, and desktop applications.","title":"What is C# used for?"},{"location":"#characteristics-of-c","text":"strongly typed (requires you to specify data types) statically typed (will check the correct types have been used before running the program) object-oriented programming language (compiled) runs on .NET framework","title":"Characteristics of C"},{"location":"#conventions-in-c","text":"use camelCase for variables use PascalCase for methods and classes use only letters, underscores, and digits in variable names every statement ends with a semicolon ( ; ) some keywords are reserved and should not be used as variable names e.g. return , break , out , continue ...","title":"Conventions in C"},{"location":"#how-to-run-c-code","text":"command in terminal = dotnet run","title":"How to run C# code"},{"location":"10_loops/","text":"Loops Loops are used to repeat instructions based on a set of conditions. Using loops helps you avoid writing redundant, repetitive code. Loops while loops do ... while loops for loops foreach loops Jump statements break continue return while loops While loops trigger as long as a condition is true. You can think of it as an if-statement that loops. Syntax: while (boolean expression) { execute this code; } Note: While loops can potentially trigger indefinitely is the condition never becomes false. This is called an infinite loop and should be avoided. do ... while loops Do... while loops are very similar to while loops but trigger once before assessing the while condition. This means that the loop will execute at least once. Syntax: do { execute this code; } while (boolean condition); for loops For loops trigger a specific number of times. An iterator variable is evaluated against a stopping condition, when the expression becomes false, the loop stops. syntax: for (int i = 0; i < 7; i += 2) { execute this code; } The three statements are: - initialization of the iterator variable - evaluation of the iterator against the stopping condition - iteration statement Important: - Don't forget to declare the iterator variable: int i = .. - The three expressions are separated by a semicolon ; - The loop stops when the stopping condition is no longer true foreach loops A foreach loop triggers for each item in a collection of values/sequence. The sequence can be an array , a string.. syntax: foreach (string element in arrayOfStrings) { execute this code; } Important: The type of the elements we are iterating over must be specified. Jump statements Jump statements are keywords used to break out of loops. break When encountering a break statement in a loop, you break out of the loop and execute the code beneath it. syntax: foreach (string item in arrayOfStrings) { Console.WriteLine(item); if (item == \"Stop\") { break; } } // resumes here continue When encountering a continue statement anywhere in a loop, you ignore the rest of the code within the loop and restart the loop from the top. syntax: foreach (string item in arrayOfStrings) { if (item == \"Skip\") { continue; // skip is not printed, and the loop moves to the next item in the array } Console.WriteLine(item); } return When encountering a return statement in a method, you break out of all loops within the method. The method ends and returns what you've specified after the return keyword. syntax: static string MyMethod(arrayOfStrings) { foreach (string item in arrayOfStrings) { if (item == \"Stop\") { return \"Sorry, we must stop here\" } Console.WriteLine(item); } return \"That's all!\" }","title":"Loops"},{"location":"10_loops/#loops","text":"Loops are used to repeat instructions based on a set of conditions. Using loops helps you avoid writing redundant, repetitive code. Loops while loops do ... while loops for loops foreach loops Jump statements break continue return","title":"Loops"},{"location":"10_loops/#while-loops","text":"While loops trigger as long as a condition is true. You can think of it as an if-statement that loops. Syntax: while (boolean expression) { execute this code; } Note: While loops can potentially trigger indefinitely is the condition never becomes false. This is called an infinite loop and should be avoided.","title":"while loops"},{"location":"10_loops/#do-while-loops","text":"Do... while loops are very similar to while loops but trigger once before assessing the while condition. This means that the loop will execute at least once. Syntax: do { execute this code; } while (boolean condition);","title":"do ... while loops"},{"location":"10_loops/#for-loops","text":"For loops trigger a specific number of times. An iterator variable is evaluated against a stopping condition, when the expression becomes false, the loop stops. syntax: for (int i = 0; i < 7; i += 2) { execute this code; } The three statements are: - initialization of the iterator variable - evaluation of the iterator against the stopping condition - iteration statement Important: - Don't forget to declare the iterator variable: int i = .. - The three expressions are separated by a semicolon ; - The loop stops when the stopping condition is no longer true","title":"for loops"},{"location":"10_loops/#foreach-loops","text":"A foreach loop triggers for each item in a collection of values/sequence. The sequence can be an array , a string.. syntax: foreach (string element in arrayOfStrings) { execute this code; } Important: The type of the elements we are iterating over must be specified.","title":"foreach loops"},{"location":"10_loops/#jump-statements","text":"Jump statements are keywords used to break out of loops.","title":"Jump statements"},{"location":"10_loops/#break","text":"When encountering a break statement in a loop, you break out of the loop and execute the code beneath it. syntax: foreach (string item in arrayOfStrings) { Console.WriteLine(item); if (item == \"Stop\") { break; } } // resumes here","title":"break"},{"location":"10_loops/#continue","text":"When encountering a continue statement anywhere in a loop, you ignore the rest of the code within the loop and restart the loop from the top. syntax: foreach (string item in arrayOfStrings) { if (item == \"Skip\") { continue; // skip is not printed, and the loop moves to the next item in the array } Console.WriteLine(item); }","title":"continue"},{"location":"10_loops/#return","text":"When encountering a return statement in a method, you break out of all loops within the method. The method ends and returns what you've specified after the return keyword. syntax: static string MyMethod(arrayOfStrings) { foreach (string item in arrayOfStrings) { if (item == \"Stop\") { return \"Sorry, we must stop here\" } Console.WriteLine(item); } return \"That's all!\" }","title":"return"},{"location":"11_classes/","text":"Classes In C#, classes are custom data types; blueprints for creating objects. Objects are instances of a class and they can contain fields, properties, and methods. Classes can be custom-defined or built-in. Class names are in PascalCase. Classes Encapsulation Built-in classes Defining a class Instantiating an object Class members Fields Properties Automatic properties Get-only properties Methods Constructors Constructor overloading Public versus private class members Static class members Static constructors Static classes Main Encapsulation Encapsulation is a characteristic of classes. It is the ability to bundle related data (properties) and methods into a type, and protect them from other code accessing it inappropriately. This is a key feature of object-oriented programming. Encapsulation makes it easier to: - reuse code - organize code Built-in classes Data types like string and array in C# are actually classes. For instance, when you create a string variable, it is an instance of the String class, and you can use various methods and properties defined in the String class. Defining a class Classes are defined in a separate file, usually called ClassName.cs . Program and other classes can access each other if they share a namespace , or when specified with the keyword using . Syntax: Define a class Forest in the namespace BasicClasses using System; namespace BasicClasses { class Forest { code of the class; } } Instantiating an object To instantiate an object means to create an instance of a class. Use the keyword new followed by ClassName() . Syntax: Instantiate a Forest object Forest lembeekseBossen = new Forest(); Class members Fields Fields are pieces of data that are variable for each instance of a class. Class fields are defined as follows: class Forest { public string name; } Public fields of an object can be instantiated and called using the object name and dot notation. Forest f = new Forest(); f.name = \"Zoni\u00ebnwoud\"; Console.WriteLine(f.name); Properties Some class fields also have a corresponding property. Properties have getters and setters that define the conditions to retrieve (get) or set a value. Getters and setters are methods. While properties often have a corresponding private field, it is not strictly required. Properties are usually named with a capitalized version of the corresponding field. Note: The purpose of a corresponding private field is to encapsulate the field and limit access to it; it is not accessible from outside the class definition. Most basic syntax: class Forest { private string name; public string Name { // the name field is set to the value given to Name set {name = value;} // when getting the Name property you will get name get {return name;} } } Forest f = new Forest(); f.Name = \"leen\"; //set Name and name Console.WriteLine(f.Name); //get Name which is name /* because name is private, you cannot get or set name with f.name, you need to use f.Name. */ You can also limit what values can be set. Example: class Forest { private string name; public string Name { set { if ((value == \"field\") || (value == \"city\")) { name = value; } else { name = \"Not actually a forest\"; } } get {return name;} } } Automatic properties The basic getter and setter syntax can be shortened using automatic properties. In that case you don't need to define a field, since a hidden (private) field will be defined in the background automatically. Long syntax: class Forest() { private string name; public string Name { get {return name;} set {name = value;} } } Short syntax: class Forest() { public string Name {get; set;} } Important: If you want to use the automatic property, you cannot reference the backing field directly, you should then always refer to the property! Get-only properties In some situations you want a property to have a getter, but no setter (if you don't want the value to be freely adaptable). There are two options: Don't define a setter: To set the value of a get-only property without setter use: - A constructor with parameter: this.Property = parameter; - An initializer public string Property {get;} = \"value\"; public int Age { get; } // Using automatic properties Define a private setter (only methods in the class can set the property value): public int Age { get; private set; } // Using automatic properties Methods Methods are chunks of code that perform a task of action. Methods belong to classes (e.g. Program). Therefore they determine how a class instance can behave. Methods are also called using dot notation: objectName.MethodName(); Methods in a custom-defined class are defined in the same way as in the Program class: see methods . They also have an access modifier, return type and name. Note: For example you can define an automatic property with a private setter and set the value using a public method. This is a safe and robust manner to control access to the class members. Constructors Constructors are special methods that set class properties when you instantiate a new object. This eliminates the need to set all properties separately by calling their setter. Constructors: Have signatures that look like other methods but they do not have a return type and their name is the same as the class name e.g. public Forest() {} Are automatically created and parameterless when not specifically defined Are called when instantiating an object: Note: It is best practice to set the properties specifically on the instance that is created, to avoid confusion. Do this by using this.Property = field . Forest lembeekseBossen = new Forest(); /* The constructor is called using new and then Forest() is the constructor */ You can set properties by setting the property names equal to the constructor parameter inputs. class Forest { // define constructor method public Forest(string name, string biome) { this.Name = name; this.Biome = biome; this.Age = 0; } // define automatic properties, biome can be set outside class public string Biome { get; set; } // define automatic get-only properties public string Name { get; private set; } public int Age { get; private set; } } //Sets properties Name and Biome (and also hidden fields) Forest lembeekseBossen = new Forest(\"LB\", \"Continental\"); Constructor overloading Since constructors are methods, you can also have multiple versions of one constructor with a different set of parameters or functionality. This is called overloading . There are three options to handle this: - Set-up separate constructor methods, each specifying how to set all properties. This option will result in redundant code, where you assign the same property in different constructors. - Set-up one constructor method with default parameter values for optional parameters - Set-up separate constructor methods but avoid redundant code by using : this() to call another constructor from the same method: class Forest { public Forest(string name, string biome) { this.Name = name; this.Biome = biome; } // : this() calls the constructor above // to set this.Name of this constructor to name // and this.Biome to \"unknown\" public Forest(string name) : this(name, \"Unknown\") { // using this option you can also add additional functionality Console.WriteLine(\"No biome specified, default value used.\") } public string Name { get; set; } public string Biome { get; set; } } Public versus private class members Class members have access modifiers that ensure protection and encapsulation of classes, either: public : accessible by other classes in the name space private : only accessible from within the class itself It is good practice to define fields as private, and the corresponding properties as public. Since properties often include validation or conditions for setting and getting fields, defining the field as private ensures that code cannot bypass validation by directly calling or setting the field. Only the property can be used. Methods should be public unless you only want to call them from within the class. Static class members Remember we talked about static vs instance methods ? Not only class methods, but all class members can be static. Static class members belong to the class itself, not to its objects. To define a static class member, use the keyword static after the access modifier and before the return type: access modifier - static keyword - return type - class member; For example: public static string Description { get; set; } To access a static member, we use the dot notation on the class , not on the object (as with instance members): // Call static property of Forest class Console.WriteLine(Forest.Description); // Call instance property of member \"lembeekseBossen\" of Forest class Console.WriteLine(lembeekseBossen.Biome); Important: Static methods can only access static fields and properties. Static constructors If you want certain static fields and properties to be set, you can do this using a static constructor : For example: static Forest() { description = \"blablabla\"; } The constructor: Uses the keyword static Does not accept an access modifier Notes: - Static constructors are automatically called before calling a static member of a class, or before instantiating a new object. - You cannot use non-static constructors to set static members, because they set properties and fields per class instance. Static classes Not only class members, but also whole classes can be static! Static classes do not have class instances. In other words, you cannot instantiate an object from a static class. Instead, they are used to group methods, like the Math class. The syntax for defining static classes is: static class ClassName { } Note: Since the class is static, you are not obliged to declare every member as static, although it is still best practice to do so. Main Lets break down the Main() method of our Program class. Class Program { public static void Main(string[] args) { } } Program is a class Main() is a method of the class Program: static: Main() acts on program itself, not on program instances ( Program.Main() ) public: Main() can be accessed by other classes of the same namespace void: Main() does not return anything string[] args: Main() has one argument, args which is an array of strings Each time you run dotnet run , Program.Main() is called. We can include arguments on the command line, like dotnet run arg1 arg2 arg3 that will be converted into an array as the args parameter.","title":"Classes"},{"location":"11_classes/#classes","text":"In C#, classes are custom data types; blueprints for creating objects. Objects are instances of a class and they can contain fields, properties, and methods. Classes can be custom-defined or built-in. Class names are in PascalCase. Classes Encapsulation Built-in classes Defining a class Instantiating an object Class members Fields Properties Automatic properties Get-only properties Methods Constructors Constructor overloading Public versus private class members Static class members Static constructors Static classes Main","title":"Classes"},{"location":"11_classes/#encapsulation","text":"Encapsulation is a characteristic of classes. It is the ability to bundle related data (properties) and methods into a type, and protect them from other code accessing it inappropriately. This is a key feature of object-oriented programming. Encapsulation makes it easier to: - reuse code - organize code","title":"Encapsulation"},{"location":"11_classes/#built-in-classes","text":"Data types like string and array in C# are actually classes. For instance, when you create a string variable, it is an instance of the String class, and you can use various methods and properties defined in the String class.","title":"Built-in classes"},{"location":"11_classes/#defining-a-class","text":"Classes are defined in a separate file, usually called ClassName.cs . Program and other classes can access each other if they share a namespace , or when specified with the keyword using . Syntax: Define a class Forest in the namespace BasicClasses using System; namespace BasicClasses { class Forest { code of the class; } }","title":"Defining a class"},{"location":"11_classes/#instantiating-an-object","text":"To instantiate an object means to create an instance of a class. Use the keyword new followed by ClassName() . Syntax: Instantiate a Forest object Forest lembeekseBossen = new Forest();","title":"Instantiating an object"},{"location":"11_classes/#class-members","text":"","title":"Class members"},{"location":"11_classes/#fields","text":"Fields are pieces of data that are variable for each instance of a class. Class fields are defined as follows: class Forest { public string name; } Public fields of an object can be instantiated and called using the object name and dot notation. Forest f = new Forest(); f.name = \"Zoni\u00ebnwoud\"; Console.WriteLine(f.name);","title":"Fields"},{"location":"11_classes/#properties","text":"Some class fields also have a corresponding property. Properties have getters and setters that define the conditions to retrieve (get) or set a value. Getters and setters are methods. While properties often have a corresponding private field, it is not strictly required. Properties are usually named with a capitalized version of the corresponding field. Note: The purpose of a corresponding private field is to encapsulate the field and limit access to it; it is not accessible from outside the class definition. Most basic syntax: class Forest { private string name; public string Name { // the name field is set to the value given to Name set {name = value;} // when getting the Name property you will get name get {return name;} } } Forest f = new Forest(); f.Name = \"leen\"; //set Name and name Console.WriteLine(f.Name); //get Name which is name /* because name is private, you cannot get or set name with f.name, you need to use f.Name. */ You can also limit what values can be set. Example: class Forest { private string name; public string Name { set { if ((value == \"field\") || (value == \"city\")) { name = value; } else { name = \"Not actually a forest\"; } } get {return name;} } }","title":"Properties"},{"location":"11_classes/#automatic-properties","text":"The basic getter and setter syntax can be shortened using automatic properties. In that case you don't need to define a field, since a hidden (private) field will be defined in the background automatically. Long syntax: class Forest() { private string name; public string Name { get {return name;} set {name = value;} } } Short syntax: class Forest() { public string Name {get; set;} } Important: If you want to use the automatic property, you cannot reference the backing field directly, you should then always refer to the property!","title":"Automatic properties"},{"location":"11_classes/#get-only-properties","text":"In some situations you want a property to have a getter, but no setter (if you don't want the value to be freely adaptable). There are two options: Don't define a setter: To set the value of a get-only property without setter use: - A constructor with parameter: this.Property = parameter; - An initializer public string Property {get;} = \"value\"; public int Age { get; } // Using automatic properties Define a private setter (only methods in the class can set the property value): public int Age { get; private set; } // Using automatic properties","title":"Get-only properties"},{"location":"11_classes/#methods","text":"Methods are chunks of code that perform a task of action. Methods belong to classes (e.g. Program). Therefore they determine how a class instance can behave. Methods are also called using dot notation: objectName.MethodName(); Methods in a custom-defined class are defined in the same way as in the Program class: see methods . They also have an access modifier, return type and name. Note: For example you can define an automatic property with a private setter and set the value using a public method. This is a safe and robust manner to control access to the class members.","title":"Methods"},{"location":"11_classes/#constructors","text":"Constructors are special methods that set class properties when you instantiate a new object. This eliminates the need to set all properties separately by calling their setter. Constructors: Have signatures that look like other methods but they do not have a return type and their name is the same as the class name e.g. public Forest() {} Are automatically created and parameterless when not specifically defined Are called when instantiating an object: Note: It is best practice to set the properties specifically on the instance that is created, to avoid confusion. Do this by using this.Property = field . Forest lembeekseBossen = new Forest(); /* The constructor is called using new and then Forest() is the constructor */ You can set properties by setting the property names equal to the constructor parameter inputs. class Forest { // define constructor method public Forest(string name, string biome) { this.Name = name; this.Biome = biome; this.Age = 0; } // define automatic properties, biome can be set outside class public string Biome { get; set; } // define automatic get-only properties public string Name { get; private set; } public int Age { get; private set; } } //Sets properties Name and Biome (and also hidden fields) Forest lembeekseBossen = new Forest(\"LB\", \"Continental\");","title":"Constructors"},{"location":"11_classes/#constructor-overloading","text":"Since constructors are methods, you can also have multiple versions of one constructor with a different set of parameters or functionality. This is called overloading . There are three options to handle this: - Set-up separate constructor methods, each specifying how to set all properties. This option will result in redundant code, where you assign the same property in different constructors. - Set-up one constructor method with default parameter values for optional parameters - Set-up separate constructor methods but avoid redundant code by using : this() to call another constructor from the same method: class Forest { public Forest(string name, string biome) { this.Name = name; this.Biome = biome; } // : this() calls the constructor above // to set this.Name of this constructor to name // and this.Biome to \"unknown\" public Forest(string name) : this(name, \"Unknown\") { // using this option you can also add additional functionality Console.WriteLine(\"No biome specified, default value used.\") } public string Name { get; set; } public string Biome { get; set; } }","title":"Constructor overloading"},{"location":"11_classes/#public-versus-private-class-members","text":"Class members have access modifiers that ensure protection and encapsulation of classes, either: public : accessible by other classes in the name space private : only accessible from within the class itself It is good practice to define fields as private, and the corresponding properties as public. Since properties often include validation or conditions for setting and getting fields, defining the field as private ensures that code cannot bypass validation by directly calling or setting the field. Only the property can be used. Methods should be public unless you only want to call them from within the class.","title":"Public versus private class members"},{"location":"11_classes/#static-class-members","text":"Remember we talked about static vs instance methods ? Not only class methods, but all class members can be static. Static class members belong to the class itself, not to its objects. To define a static class member, use the keyword static after the access modifier and before the return type: access modifier - static keyword - return type - class member; For example: public static string Description { get; set; } To access a static member, we use the dot notation on the class , not on the object (as with instance members): // Call static property of Forest class Console.WriteLine(Forest.Description); // Call instance property of member \"lembeekseBossen\" of Forest class Console.WriteLine(lembeekseBossen.Biome); Important: Static methods can only access static fields and properties.","title":"Static class members"},{"location":"11_classes/#static-constructors","text":"If you want certain static fields and properties to be set, you can do this using a static constructor : For example: static Forest() { description = \"blablabla\"; } The constructor: Uses the keyword static Does not accept an access modifier Notes: - Static constructors are automatically called before calling a static member of a class, or before instantiating a new object. - You cannot use non-static constructors to set static members, because they set properties and fields per class instance.","title":"Static constructors"},{"location":"11_classes/#static-classes","text":"Not only class members, but also whole classes can be static! Static classes do not have class instances. In other words, you cannot instantiate an object from a static class. Instead, they are used to group methods, like the Math class. The syntax for defining static classes is: static class ClassName { } Note: Since the class is static, you are not obliged to declare every member as static, although it is still best practice to do so.","title":"Static classes"},{"location":"11_classes/#main","text":"Lets break down the Main() method of our Program class. Class Program { public static void Main(string[] args) { } } Program is a class Main() is a method of the class Program: static: Main() acts on program itself, not on program instances ( Program.Main() ) public: Main() can be accessed by other classes of the same namespace void: Main() does not return anything string[] args: Main() has one argument, args which is an array of strings Each time you run dotnet run , Program.Main() is called. We can include arguments on the command line, like dotnet run arg1 arg2 arg3 that will be converted into an array as the args parameter.","title":"Main"},{"location":"12_interfaces/","text":"Interfaces Interfaces help check wether all classes and types are used legally to prevent type errors. They enable you to define methods and properties that are shared across classes, but implemented differently. Interfaces make sure you don't define ten different method names for related classes. Interfaces In words Defining an interface Implementing an interface Implementing more than one interface In words An interface is a set of properties and methods without implementation details. An interface can be implemented by one or more classes . For a class to implement an interface, it must define an implementation for all properties and methods of the interface. Note: A class that implements an interface may have properties and methods on top of those defined by the interface. Defining an interface Interfaces are defined in a separate file, usually called IInterfaceName.cs . Classes can access an interface if they share a namespace , or when specified with the keyword using . Syntax: MyInterfaces.cs defines an interface Prey in the namespace MyInterfaces using System; namespace MyInterfaces { interface IPrey { string Description {get;} void Flee(); } } Use the keyword interface Start the interface name with I and use PascalCase Define a set of properties (with methods) and methods but no implementation Don't use access modifiers Note: An interface cannot define constructors and fields. Implementing an interface To implement an interface means to tell a class what properties and methods it must have. Use ClassName : IInterfaceName . Syntax: Deer.cs defines a class Deer that implements the IPrey interface class Deer : IPrey { public Deer(string description) { this.Description = description; } public string Description {get;} public void Flee() { Console.WriteLine(\"I'm outta here!\"); } } The syntax class ClassName : IInterfaceName is a promise that the class will implement an interface. If it does not, an error will be thrown. This can be seen as a check that nothing was forgotten. Note: All properties and methods defined in the interface, must be public in the class that implements it. This is because these properties and methods need to be available to other code using the interface. Implementing more than one interface The syntax for a Truck class that implements two interfaces: IAutomobile and IRecyclable is: class Truck : IAutomobile, IRecyclable { code; } Just separate the implemented interfaces with a comma.","title":"Interfaces"},{"location":"12_interfaces/#interfaces","text":"Interfaces help check wether all classes and types are used legally to prevent type errors. They enable you to define methods and properties that are shared across classes, but implemented differently. Interfaces make sure you don't define ten different method names for related classes. Interfaces In words Defining an interface Implementing an interface Implementing more than one interface","title":"Interfaces"},{"location":"12_interfaces/#in-words","text":"An interface is a set of properties and methods without implementation details. An interface can be implemented by one or more classes . For a class to implement an interface, it must define an implementation for all properties and methods of the interface. Note: A class that implements an interface may have properties and methods on top of those defined by the interface.","title":"In words"},{"location":"12_interfaces/#defining-an-interface","text":"Interfaces are defined in a separate file, usually called IInterfaceName.cs . Classes can access an interface if they share a namespace , or when specified with the keyword using . Syntax: MyInterfaces.cs defines an interface Prey in the namespace MyInterfaces using System; namespace MyInterfaces { interface IPrey { string Description {get;} void Flee(); } } Use the keyword interface Start the interface name with I and use PascalCase Define a set of properties (with methods) and methods but no implementation Don't use access modifiers Note: An interface cannot define constructors and fields.","title":"Defining an interface"},{"location":"12_interfaces/#implementing-an-interface","text":"To implement an interface means to tell a class what properties and methods it must have. Use ClassName : IInterfaceName . Syntax: Deer.cs defines a class Deer that implements the IPrey interface class Deer : IPrey { public Deer(string description) { this.Description = description; } public string Description {get;} public void Flee() { Console.WriteLine(\"I'm outta here!\"); } } The syntax class ClassName : IInterfaceName is a promise that the class will implement an interface. If it does not, an error will be thrown. This can be seen as a check that nothing was forgotten. Note: All properties and methods defined in the interface, must be public in the class that implements it. This is because these properties and methods need to be available to other code using the interface.","title":"Implementing an interface"},{"location":"12_interfaces/#implementing-more-than-one-interface","text":"The syntax for a Truck class that implements two interfaces: IAutomobile and IRecyclable is: class Truck : IAutomobile, IRecyclable { code; } Just separate the implemented interfaces with a comma.","title":"Implementing more than one interface"},{"location":"13_inheritance/","text":"Inheritance Inheritance is useful when different classes share class members but also have some unique members. A superclass holds the shared members, and subclasses inherit from this superclass. Additionally, the subclasses contain their own unique members. Note: Are you confused by the difference between interfaces and superclasses? - Use interfaces for shared characteristics between classes that do not necessary have a common hierarchical parent, or when implementations of the members differs between classes. - Use superclasses for classes that have a common hierarchical parent and when the implementation of the shared members is exactly the same. Inheritance Superclass Syntax Subclass Syntax Visual example of superclass and subclasses Inheritance rules Access modifier: protected Base keyword Example: constructor re-use Virtual/override modifiers Abstract/override modifiers Superclass A superclass is a class that contains members that are shared by all its subclasses. Syntax The syntax of a superclass is no different from a normal class, you know it is a superclass because another class implements it. class Vehicle { \"shared members\"; } Note: A superclass is also know as a base class. Subclass A subclass is a class that inherits all members of its superclass, without having to duplicate their code. Additionally the subclass also has members of its own. Subclass member Defined Inherited In superclass Unique In subclass Note: A subclass is also known as a derived class. Syntax A subclass inherits a superclass using the : syntax. Be careful, classes must specify the superclass they inherit before specifying any interfaces they implement. class Car : Vehicle, IDrives, IRecyclable { \"unique members\"; } Visual example of superclass and subclasses classDiagram Vehicle --> Car Vehicle --> Train class Vehicle { String make String model int year startEngine() stopEngine() } class Car { boolean isConvertible openTrunk() closeTrunk() } class Train { int numberOfCarriages coupleCarriage() decoupleCarriage() } Car and Train both have all properties and methods of Vehicle , plus some of their own. You don't need to define the superclass properties again in the subclass. This results in less duplicate code. Inheritance rules Multiple hierarchical levels are possible: a superclass can be a subclass of another superclass. For example: Car is a superclass of Audi , but a subclass of Vehicle . A subclass can inherit from only one superclass Note: Remember that a class can implement multiple interfaces, but only inherit from one superclass. Classes must specify the superclass they inherit before specifying any interfaces they implement Access modifier: protected Sometimes we need to set the value of a superclass property in a member of its subclass. When the access modifier for the setter is private , the subclass cannot access it. However, when the setter is public , there might be security risks. To solve this, you can use the access modifier protected . Protected enables access by the superclass and its subclasses, but not by other code. Base keyword The base keyword can be used in subclasses to refer to members of its superclass. Just like using this for properties of a class instance, it can increase readability of your code. The base keyword is often used to inherit the constructor of the superclass in the subclass. For another use of base, refer to Virtual/Override modifiers . Example: constructor re-use Before constructor re-use: class Vehicle { public Vehicle(double speed) { this.Speed = speed; this.Plate = Tools.GenerateLicensePlate(); } // note that Speed and Plate must have protected setters // to be able to access them in Car public int Speed { get; protected set; } public string Plate { get; protected set; } } class Car : Vehicle { public Car(double speed) { // even though Speed and Plate are members of the superclass // we still prefer to use this // because we are constructing an instance of the subclass this.Speed = speed; this.Plate = Tools.GenerateLicensePlate(); this.Wheels = 4; } public int Wheels { get; private set; } } After constructor re-use (note the setters in Vehicle can be set to private again) : class Vehicle { public Vehicle(double speed) { this.Speed = speed; this.plate = Tools.GenerateLicensePlate(); } // note that Speed and Plate can have a private setter // if the base constructor is used in subclasses to set the properties public int Speed { get; private set; } public string Plate { get; private set; } } class Car : Vehicle { // don't need to set the properties that are already set in base public Car(double speed) : base(speed) { this.Wheels = 4; } public int Wheels { get; private set; } } Virtual/override modifiers If we define a method in a superclass, our subclass also has this method. But what if we want the method to be slightly different or extended in the subclass? Label the method in the superclass with virtual (can be overwritten) Label the method in the subclass with override Write your new code in the subclass method. If you want to re-use parts of the superclass method, use base.MethodName . Example: Class Vehicle { public int Speed { get; protected set; } public virtual void SpeedUp() { this.Speed += 5; } } Class Car { public override void SpeedUp() { base.SpeedUp(); if (this.Speed > 15) { this.Speed = 15; } } } Abstract/override modifiers What if you want to define a different version of the same method for every subclass of the superclass? In that case there is no default method that we can override. You will need to define an abstract method in the superclass, that has no implementation: public abstract string Describe(); However, if this method has no implementation in the superclass, then we cannot have instances of that superclass. This means we need to make the whole class abstract ! abstract class Vehicle { public abstract string Describe(); } Our subclasses inherit the abstract method and must implement it. To show that we are not just adding a new method, we also need to use override here: class Car : Vehicle { public override string Describe() { Console.WriteLine(\"blabla\"); } } Note: This is very similar to interfaces, but used when you need a mix between inheritance and implementation.","title":"Inheritance"},{"location":"13_inheritance/#inheritance","text":"Inheritance is useful when different classes share class members but also have some unique members. A superclass holds the shared members, and subclasses inherit from this superclass. Additionally, the subclasses contain their own unique members. Note: Are you confused by the difference between interfaces and superclasses? - Use interfaces for shared characteristics between classes that do not necessary have a common hierarchical parent, or when implementations of the members differs between classes. - Use superclasses for classes that have a common hierarchical parent and when the implementation of the shared members is exactly the same. Inheritance Superclass Syntax Subclass Syntax Visual example of superclass and subclasses Inheritance rules Access modifier: protected Base keyword Example: constructor re-use Virtual/override modifiers Abstract/override modifiers","title":"Inheritance"},{"location":"13_inheritance/#superclass","text":"A superclass is a class that contains members that are shared by all its subclasses.","title":"Superclass"},{"location":"13_inheritance/#syntax","text":"The syntax of a superclass is no different from a normal class, you know it is a superclass because another class implements it. class Vehicle { \"shared members\"; } Note: A superclass is also know as a base class.","title":"Syntax"},{"location":"13_inheritance/#subclass","text":"A subclass is a class that inherits all members of its superclass, without having to duplicate their code. Additionally the subclass also has members of its own. Subclass member Defined Inherited In superclass Unique In subclass Note: A subclass is also known as a derived class.","title":"Subclass"},{"location":"13_inheritance/#syntax_1","text":"A subclass inherits a superclass using the : syntax. Be careful, classes must specify the superclass they inherit before specifying any interfaces they implement. class Car : Vehicle, IDrives, IRecyclable { \"unique members\"; }","title":"Syntax"},{"location":"13_inheritance/#visual-example-of-superclass-and-subclasses","text":"classDiagram Vehicle --> Car Vehicle --> Train class Vehicle { String make String model int year startEngine() stopEngine() } class Car { boolean isConvertible openTrunk() closeTrunk() } class Train { int numberOfCarriages coupleCarriage() decoupleCarriage() } Car and Train both have all properties and methods of Vehicle , plus some of their own. You don't need to define the superclass properties again in the subclass. This results in less duplicate code.","title":"Visual example of superclass and subclasses"},{"location":"13_inheritance/#inheritance-rules","text":"Multiple hierarchical levels are possible: a superclass can be a subclass of another superclass. For example: Car is a superclass of Audi , but a subclass of Vehicle . A subclass can inherit from only one superclass Note: Remember that a class can implement multiple interfaces, but only inherit from one superclass. Classes must specify the superclass they inherit before specifying any interfaces they implement","title":"Inheritance rules"},{"location":"13_inheritance/#access-modifier-protected","text":"Sometimes we need to set the value of a superclass property in a member of its subclass. When the access modifier for the setter is private , the subclass cannot access it. However, when the setter is public , there might be security risks. To solve this, you can use the access modifier protected . Protected enables access by the superclass and its subclasses, but not by other code.","title":"Access modifier: protected"},{"location":"13_inheritance/#base-keyword","text":"The base keyword can be used in subclasses to refer to members of its superclass. Just like using this for properties of a class instance, it can increase readability of your code. The base keyword is often used to inherit the constructor of the superclass in the subclass. For another use of base, refer to Virtual/Override modifiers .","title":"Base keyword"},{"location":"13_inheritance/#example-constructor-re-use","text":"Before constructor re-use: class Vehicle { public Vehicle(double speed) { this.Speed = speed; this.Plate = Tools.GenerateLicensePlate(); } // note that Speed and Plate must have protected setters // to be able to access them in Car public int Speed { get; protected set; } public string Plate { get; protected set; } } class Car : Vehicle { public Car(double speed) { // even though Speed and Plate are members of the superclass // we still prefer to use this // because we are constructing an instance of the subclass this.Speed = speed; this.Plate = Tools.GenerateLicensePlate(); this.Wheels = 4; } public int Wheels { get; private set; } } After constructor re-use (note the setters in Vehicle can be set to private again) : class Vehicle { public Vehicle(double speed) { this.Speed = speed; this.plate = Tools.GenerateLicensePlate(); } // note that Speed and Plate can have a private setter // if the base constructor is used in subclasses to set the properties public int Speed { get; private set; } public string Plate { get; private set; } } class Car : Vehicle { // don't need to set the properties that are already set in base public Car(double speed) : base(speed) { this.Wheels = 4; } public int Wheels { get; private set; } }","title":"Example: constructor re-use"},{"location":"13_inheritance/#virtualoverride-modifiers","text":"If we define a method in a superclass, our subclass also has this method. But what if we want the method to be slightly different or extended in the subclass? Label the method in the superclass with virtual (can be overwritten) Label the method in the subclass with override Write your new code in the subclass method. If you want to re-use parts of the superclass method, use base.MethodName . Example: Class Vehicle { public int Speed { get; protected set; } public virtual void SpeedUp() { this.Speed += 5; } } Class Car { public override void SpeedUp() { base.SpeedUp(); if (this.Speed > 15) { this.Speed = 15; } } }","title":"Virtual/override modifiers"},{"location":"13_inheritance/#abstractoverride-modifiers","text":"What if you want to define a different version of the same method for every subclass of the superclass? In that case there is no default method that we can override. You will need to define an abstract method in the superclass, that has no implementation: public abstract string Describe(); However, if this method has no implementation in the superclass, then we cannot have instances of that superclass. This means we need to make the whole class abstract ! abstract class Vehicle { public abstract string Describe(); } Our subclasses inherit the abstract method and must implement it. To show that we are not just adding a new method, we also need to use override here: class Car : Vehicle { public override string Describe() { Console.WriteLine(\"blabla\"); } } Note: This is very similar to interfaces, but used when you need a mix between inheritance and implementation.","title":"Abstract/override modifiers"},{"location":"14_references_polymorphism/","text":"References and polymorphism In C# some types are reference types , while others are value types . Variables of a value type actually hold data, while variables of a reference type hold a reference to data. This has implications when you assign a new variable to an existing one: a new copy of the data is created for value types, but merely a new reference to the same data is created for reference types. References and polymorphism Reference vs Value types Reference types Value types Assigning a new variable to an existing one Comparison of variables (with boolean expressions) References of different types Use of references of different type than the object it refers to Polymorphism Up-and downcasting of references Missing vs unassigned reference variables Reference vs Value types Reference types Remember, reference types refer to a place in memory, they don't hold actual data. The reference types in C# are: class interface delegate object string (immutable, behavior is different) array dynamic Value types Remember, value types hold actual data. All primitive data types are value types. The value types in C# are: int bool char (s)byte (u)short (u)long float double decimal struct enum Assigning a new variable to an existing one When assigning a new variable to an existing one, their independence depends on wether they are value or reference types. Lets look at some examples to understand the difference. Example value type: int int1 = 20; int int2 = int1; int2 = 10; Console.WriteLine(int1); //output: 20 Console.WriteLine(int2); //output: 10 Example reference type: Forest forest1 = new Forest(); Forest forest2 = forest1; forest1.name = \"Leen\" forest2.name = \"Woud\"; Console.WriteLine(forest1); //output: \"Woud\" Console.WriteLine(forest2); //output: \"Woud\" Comparison of variables (with boolean expressions) We compare two variables with a comparison operator: variable1 == variable2; This expression performs a different check depending on wether the variables are value or reference types. The comparison expression returns true if the variables of type: value type: hold the same data ( value comparison ) reference type: refer to the same location in memory ( referential comparison ) Note: When two independently created objects hold class instances with the same values, the check will return false . References of different types It is possible to create a refer to an object of a certain class (e.g. Dog ) using a variable of its parent class ( Animal ) or with the interface ( IFourLegged ) it implements. These references of class Animal or of interface IFourLegged are equal to the original Dog variable in referential comparison: Dog pluto = new Dog(); Animal apluto = pluto; IFourLegged ipluto = pluto; Console.writeLine(pluto == apluto); // returns true Console.writeLine(pluto == ipluto); // returns true Console.writeLine(apluto == ipluto); // returns true However, we can only use methods or properties of the Animal class on apluto , and we can only use the properties and methods defined in IFourLegged on ipluto . Essentially, the variables point to the same location in memory but can only access the properties and methods determined by their decalred type. Use of references of different type than the object it refers to Maybe you wonder when you need reference to an object of a different type than the object itself. Let up find out through an example: Dog pluto = new Dog(); Dog snoopy = new Dog(); Cat mousti = new Cat(); Cat kitty = new Cat(); // if we had no references of different types: pluto.Sleep(); snoopy.Sleep(); mousti.Sleep(); kitty.Sleep(); // simplified and cleaned code thanks to references of different types Animal[] animals = new Animal[] {pluto, snoopy, mousti, kitty};s foreach (Animal a in animals) { a.Sleep(); } Imagine that you instantiate a bunch of animals from Animal subclasses Dog an Cat . If you want to make all of them sleep, you need to duplicate code for each variable and can't use a loop, because items in an array must be of one type. However, you can create a list of Animal references to your animals, and loop through it. Important: The variables in animals are Animal references to Dog and Cat objects! We can only call properties and methods of the Animal class but we will get values according to their implementation defined in the Dog and Cat classes. This is due to polymorphism Note: You can also create references to the Object type if you don't know any common interfaces or base classes. Polymorphism Polymorphism is a Greek word that means to have many forms . In C# polymorphism means that Object can be identified by more than one type, or referred to by more than one type. Objects maintain functionality unique to their data type (even if referenced with a different type, see uses of references ) For a concrete example, please refer to this video . Up-and downcasting of references Upcasting of references is creating a base class or interface reference from a subclass reference . This will always work and can be done implicitly. Downcasting of references is creating a subclass reference from a base class or interface reference . This will only work when the reference referred to an object of the subclass type and must be done explicitly to acknowledge that you are taking the risk that the operation might fail. To illustrate ( Book is the base class and Dissertation the subclass): Dissertation diss = new Dissertation(); // upcast Book bdiss = diss; // successful downcast: bdiss referred to a dissertation object Dissertation ddiss = (Dissertation)bdiss; Book bk = new Book(); // unsuccessful downcast: bk did not refer to a dissertation object Dissertation dbk = (Dissertation)bk; Missing vs unassigned reference variables In C# there is a difference between empty/missing references: Book bk = null; And unassigned references: Book bk2; You can use missing references for operations because they have a value (null), but not unassigned references. This is illustrated below: // missing reference bk of type Book Book bk = null; Console.WriteLine(bk); //prints nothing because empty Console.WriteLine(bk == null); //prints true // unassigned reference bk2 of type Book Book bk2; Console.WriteLine(bk); // err: use of unassigned variable bk2 Console.WriteLine(bk2 == null); // err: use of unassigned variable bk2 // contains 5 unassigned Book type references in an array, but C# automatically then assigns null to them Book[] books = new Book[5]; // contains 5 missing Book type references in an array (functionally equivalent to the statement above) Book[] books = new Book[] {null, null, null, null, null}","title":"References and polymorphism"},{"location":"14_references_polymorphism/#references-and-polymorphism","text":"In C# some types are reference types , while others are value types . Variables of a value type actually hold data, while variables of a reference type hold a reference to data. This has implications when you assign a new variable to an existing one: a new copy of the data is created for value types, but merely a new reference to the same data is created for reference types. References and polymorphism Reference vs Value types Reference types Value types Assigning a new variable to an existing one Comparison of variables (with boolean expressions) References of different types Use of references of different type than the object it refers to Polymorphism Up-and downcasting of references Missing vs unassigned reference variables","title":"References and polymorphism"},{"location":"14_references_polymorphism/#reference-vs-value-types","text":"","title":"Reference vs Value types"},{"location":"14_references_polymorphism/#reference-types","text":"Remember, reference types refer to a place in memory, they don't hold actual data. The reference types in C# are: class interface delegate object string (immutable, behavior is different) array dynamic","title":"Reference types"},{"location":"14_references_polymorphism/#value-types","text":"Remember, value types hold actual data. All primitive data types are value types. The value types in C# are: int bool char (s)byte (u)short (u)long float double decimal struct enum","title":"Value types"},{"location":"14_references_polymorphism/#assigning-a-new-variable-to-an-existing-one","text":"When assigning a new variable to an existing one, their independence depends on wether they are value or reference types. Lets look at some examples to understand the difference. Example value type: int int1 = 20; int int2 = int1; int2 = 10; Console.WriteLine(int1); //output: 20 Console.WriteLine(int2); //output: 10 Example reference type: Forest forest1 = new Forest(); Forest forest2 = forest1; forest1.name = \"Leen\" forest2.name = \"Woud\"; Console.WriteLine(forest1); //output: \"Woud\" Console.WriteLine(forest2); //output: \"Woud\"","title":"Assigning a new variable to an existing one"},{"location":"14_references_polymorphism/#comparison-of-variables-with-boolean-expressions","text":"We compare two variables with a comparison operator: variable1 == variable2; This expression performs a different check depending on wether the variables are value or reference types. The comparison expression returns true if the variables of type: value type: hold the same data ( value comparison ) reference type: refer to the same location in memory ( referential comparison ) Note: When two independently created objects hold class instances with the same values, the check will return false .","title":"Comparison of variables (with boolean expressions)"},{"location":"14_references_polymorphism/#references-of-different-types","text":"It is possible to create a refer to an object of a certain class (e.g. Dog ) using a variable of its parent class ( Animal ) or with the interface ( IFourLegged ) it implements. These references of class Animal or of interface IFourLegged are equal to the original Dog variable in referential comparison: Dog pluto = new Dog(); Animal apluto = pluto; IFourLegged ipluto = pluto; Console.writeLine(pluto == apluto); // returns true Console.writeLine(pluto == ipluto); // returns true Console.writeLine(apluto == ipluto); // returns true However, we can only use methods or properties of the Animal class on apluto , and we can only use the properties and methods defined in IFourLegged on ipluto . Essentially, the variables point to the same location in memory but can only access the properties and methods determined by their decalred type.","title":"References of different types"},{"location":"14_references_polymorphism/#use-of-references-of-different-type-than-the-object-it-refers-to","text":"Maybe you wonder when you need reference to an object of a different type than the object itself. Let up find out through an example: Dog pluto = new Dog(); Dog snoopy = new Dog(); Cat mousti = new Cat(); Cat kitty = new Cat(); // if we had no references of different types: pluto.Sleep(); snoopy.Sleep(); mousti.Sleep(); kitty.Sleep(); // simplified and cleaned code thanks to references of different types Animal[] animals = new Animal[] {pluto, snoopy, mousti, kitty};s foreach (Animal a in animals) { a.Sleep(); } Imagine that you instantiate a bunch of animals from Animal subclasses Dog an Cat . If you want to make all of them sleep, you need to duplicate code for each variable and can't use a loop, because items in an array must be of one type. However, you can create a list of Animal references to your animals, and loop through it. Important: The variables in animals are Animal references to Dog and Cat objects! We can only call properties and methods of the Animal class but we will get values according to their implementation defined in the Dog and Cat classes. This is due to polymorphism Note: You can also create references to the Object type if you don't know any common interfaces or base classes.","title":"Use of references of different type than the object it refers to"},{"location":"14_references_polymorphism/#polymorphism","text":"Polymorphism is a Greek word that means to have many forms . In C# polymorphism means that Object can be identified by more than one type, or referred to by more than one type. Objects maintain functionality unique to their data type (even if referenced with a different type, see uses of references ) For a concrete example, please refer to this video .","title":"Polymorphism"},{"location":"14_references_polymorphism/#up-and-downcasting-of-references","text":"Upcasting of references is creating a base class or interface reference from a subclass reference . This will always work and can be done implicitly. Downcasting of references is creating a subclass reference from a base class or interface reference . This will only work when the reference referred to an object of the subclass type and must be done explicitly to acknowledge that you are taking the risk that the operation might fail. To illustrate ( Book is the base class and Dissertation the subclass): Dissertation diss = new Dissertation(); // upcast Book bdiss = diss; // successful downcast: bdiss referred to a dissertation object Dissertation ddiss = (Dissertation)bdiss; Book bk = new Book(); // unsuccessful downcast: bk did not refer to a dissertation object Dissertation dbk = (Dissertation)bk;","title":"Up-and downcasting of references"},{"location":"14_references_polymorphism/#missing-vs-unassigned-reference-variables","text":"In C# there is a difference between empty/missing references: Book bk = null; And unassigned references: Book bk2; You can use missing references for operations because they have a value (null), but not unassigned references. This is illustrated below: // missing reference bk of type Book Book bk = null; Console.WriteLine(bk); //prints nothing because empty Console.WriteLine(bk == null); //prints true // unassigned reference bk2 of type Book Book bk2; Console.WriteLine(bk); // err: use of unassigned variable bk2 Console.WriteLine(bk2 == null); // err: use of unassigned variable bk2 // contains 5 unassigned Book type references in an array, but C# automatically then assigns null to them Book[] books = new Book[5]; // contains 5 missing Book type references in an array (functionally equivalent to the statement above) Book[] books = new Book[] {null, null, null, null, null}","title":"Missing vs unassigned reference variables"},{"location":"15_object_class/","text":"The Object class The Object class is the superclass at the highest level of the class hierarchy. All classes directly or indirectly inherit from the Object class. The Object class Upcasting to Object Uses of the Object type Object members Note: All types inherit from the Object class, even value types. Therefore Object ob1 = \"hello\" and Object ob2 = 5 are valid. Upcasting to Object Since Object is at the top of the class hierarchy, you can upcast any reference to type Object! Uses of the Object type When you don't know the type of an object, you can use Object There are some useful members in the Object class (properties and methods) Object members Since all types inherit from the Object type, all types can access Object members. Some of these members are: Member Description Virtual? x.GetType() returns the type of x no x.ToString() returns a string description of x yes, you can use override x.Equals(y) returns true if x == y and false if x != y ( see comparison of variables ) yes, you can use override Note: Console.WriteLine() uses the ToString() Object method under the hood: When you pass a variable to Console.WriteLine() , the ToString() method is called on that variable and the result is printed to the console. This also means that you can change what is printed to the console by overriding the ToString() method in your class definition .","title":"The object class"},{"location":"15_object_class/#the-object-class","text":"The Object class is the superclass at the highest level of the class hierarchy. All classes directly or indirectly inherit from the Object class. The Object class Upcasting to Object Uses of the Object type Object members Note: All types inherit from the Object class, even value types. Therefore Object ob1 = \"hello\" and Object ob2 = 5 are valid.","title":"The Object class"},{"location":"15_object_class/#upcasting-to-object","text":"Since Object is at the top of the class hierarchy, you can upcast any reference to type Object!","title":"Upcasting to Object"},{"location":"15_object_class/#uses-of-the-object-type","text":"When you don't know the type of an object, you can use Object There are some useful members in the Object class (properties and methods)","title":"Uses of the Object type"},{"location":"15_object_class/#object-members","text":"Since all types inherit from the Object type, all types can access Object members. Some of these members are: Member Description Virtual? x.GetType() returns the type of x no x.ToString() returns a string description of x yes, you can use override x.Equals(y) returns true if x == y and false if x != y ( see comparison of variables ) yes, you can use override Note: Console.WriteLine() uses the ToString() Object method under the hood: When you pass a variable to Console.WriteLine() , the ToString() method is called on that variable and the result is printed to the console. This also means that you can change what is printed to the console by overriding the ToString() method in your class definition .","title":"Object members"},{"location":"16_strings_advanced/","text":"Advanced info on strings String is actually a reference type, it's a class that represents text and the value is stored as a collection of char objects. However, it does not have all the same characteristics as other reference types. Advanced info on strings Differences with other reference types Strings are immutable Missing, unassigned, and empty strings String as a class Differences with other reference types In some regards, the String class/reference type behaves like value types: When you assign a string variable to an existing string variable, and change one instance, the other will not be changed. This is a consequence of the immutability of strings Comparison between two strings using a boolean expression behaves like a value comparison (values are compared, not wether they refer to the same object) Note: string and String are interchangeable, the string syntax is used because of its similarity to value types and not to confuse beginning programmers. Strings are immutable String objects cannot be modified once they are created, it only seems that they can because whenever a modification operation happens, a new string is actually created in the background. When you assign a new variable to an existing string , they initially point to the same object. However, as soon as a modification to one variable happens, a new string object is created and the references no longer point to the same string object. Missing, unassigned, and empty strings Since strings are reference types, they can be unassigned or missing (equal to null ). Strings also have a third way of remaining without value; they can be empty. Declaring an empty string can be done in two ways: string a = \"\"; //or string a = String.Empty; The String class ( static ) method IsNullOrEmpty() accepts a string and returns a boolean that tells you wether or not the string is null or empty. Note: It is advised to use an empty string instead of a missing string ( null ) to avoid errors. String as a class Since String is also a class, there are several properties and methods that can be called on string instances or class. Examples: static method IsNullOrEmpty() x.Replace(string, string) replaces all instances of the first string by the second String.Empty static property","title":"Strings (advanced)"},{"location":"16_strings_advanced/#advanced-info-on-strings","text":"String is actually a reference type, it's a class that represents text and the value is stored as a collection of char objects. However, it does not have all the same characteristics as other reference types. Advanced info on strings Differences with other reference types Strings are immutable Missing, unassigned, and empty strings String as a class","title":"Advanced info on strings"},{"location":"16_strings_advanced/#differences-with-other-reference-types","text":"In some regards, the String class/reference type behaves like value types: When you assign a string variable to an existing string variable, and change one instance, the other will not be changed. This is a consequence of the immutability of strings Comparison between two strings using a boolean expression behaves like a value comparison (values are compared, not wether they refer to the same object) Note: string and String are interchangeable, the string syntax is used because of its similarity to value types and not to confuse beginning programmers.","title":"Differences with other reference types"},{"location":"16_strings_advanced/#strings-are-immutable","text":"String objects cannot be modified once they are created, it only seems that they can because whenever a modification operation happens, a new string is actually created in the background. When you assign a new variable to an existing string , they initially point to the same object. However, as soon as a modification to one variable happens, a new string object is created and the references no longer point to the same string object.","title":"Strings are immutable"},{"location":"16_strings_advanced/#missing-unassigned-and-empty-strings","text":"Since strings are reference types, they can be unassigned or missing (equal to null ). Strings also have a third way of remaining without value; they can be empty. Declaring an empty string can be done in two ways: string a = \"\"; //or string a = String.Empty; The String class ( static ) method IsNullOrEmpty() accepts a string and returns a boolean that tells you wether or not the string is null or empty. Note: It is advised to use an empty string instead of a missing string ( null ) to avoid errors.","title":"Missing, unassigned, and empty strings"},{"location":"16_strings_advanced/#string-as-a-class","text":"Since String is also a class, there are several properties and methods that can be called on string instances or class. Examples: static method IsNullOrEmpty() x.Replace(string, string) replaces all instances of the first string by the second String.Empty static property","title":"String as a class"},{"location":"17_lists/","text":"Lists Lists might remind you of arrays because they have similar characteristics: both are a sequential collection of values and can hold any type. But unlike arrays, lists have a flexible length, they automatically track the number of elements in the list, and you can work with multiple list items at once using methods. Lists Syntax Accessing and editing list elements Namespace generic collections Generic collections Lists are dynamic Other built-in properties and methods Why use arrays? Syntax To declare an array of strings we used the following syntax: // empty array, must specify # of elements string[] emptyArray = new string[3] // array with values string[] letterArray = new string[] {\"x\", \"y\", \"z\"}; To declare a list of strings we use: // empty list, don't need to specify # of elements List<string> emptyList = new List<string>(); // list with values List<string> letterList = new List<string> {\"x\", \"y\", \"z\"}; Accessing and editing list elements The syntax for accessing and editing list elements is identical to the syntax for array element accessing and editing . Namespace generic collections To work with lists in C#, we need to include a namespace in our code. Just add the line: using System.Collections.Generic; This references generic collections , a group of classes to which the list class belongs. Note: Dictionaries are also a class belonging to generic collections. Generic collections Generic collections are data structures that are defined without specifying a type. Only upon creation of an instance, the type of the collection is defined ( List<string> vs List<double> ). The formal class name of lists is List<T> for this reason. Note: Even though arrays are not generic collections, there also isn't a separate class for every array type (only System.Array ) Lists are dynamic Lists are basically the dynamic version of arrays, we can add/remove one or more elements to/from the list using methods. The indexes change when list elements are removed and added. Note: To avoid errors for trying to access index values that do not exist, you can find the max index value of a list x at a given moment by calling x.Count-1 . Method Description x.Add(elementA) Add one element, elementA to the list x.Remove(elementA) Remove one element, elementA from the list. Returns a boolean to indicate if this was successful x.AddRange(new T[] {elementA, elementB,...}) * Add multiple elements, e.g. elementA and elementB to the list x.InsertRange(ind, new T[] {elementA, elementB,...}) * Add multiple elements, e.g. elementA and elementB to the list at (not after!) the index specified by ind x.RemoveRange(new T[] {elementA, elementB,...}) * Remove multiple elements, e.g. elementA and elementB to the list x.GetRange(ind, count) Returns a list containing count elements from list x starting from index ind x.Clear() Remove all elements from the list, the count also changes Note: The AddRange() and RemoveRange() list methods accept any IEnumerable type. This includes lists, dictionaries, hashsets, queues, arrays... Other built-in properties and methods Property/method Description x.Count Returns the number of elements in the list* x.Contains(elementA) Returns a boolean, true is the element, elementA is a member of the list x.Reverse() Reverses the order of the elements in the list x.Reverse(ind, count) Overload of x.Reverse() where you specify what portion of the list to reverse, count elements starting from ind Note: For the number of elements in an array or string, we use .Length . For Lists we use .Count , this distinction stresses the difference between fixed length types and flexible types that must be counted. Why use arrays? Lists actually use arrays under the hood, copying all members to a new array with the modified length whenever necessary. Therefore, using an array is faster and makes more sense when you have a fixed number of elements.","title":"Lists"},{"location":"17_lists/#lists","text":"Lists might remind you of arrays because they have similar characteristics: both are a sequential collection of values and can hold any type. But unlike arrays, lists have a flexible length, they automatically track the number of elements in the list, and you can work with multiple list items at once using methods. Lists Syntax Accessing and editing list elements Namespace generic collections Generic collections Lists are dynamic Other built-in properties and methods Why use arrays?","title":"Lists"},{"location":"17_lists/#syntax","text":"To declare an array of strings we used the following syntax: // empty array, must specify # of elements string[] emptyArray = new string[3] // array with values string[] letterArray = new string[] {\"x\", \"y\", \"z\"}; To declare a list of strings we use: // empty list, don't need to specify # of elements List<string> emptyList = new List<string>(); // list with values List<string> letterList = new List<string> {\"x\", \"y\", \"z\"};","title":"Syntax"},{"location":"17_lists/#accessing-and-editing-list-elements","text":"The syntax for accessing and editing list elements is identical to the syntax for array element accessing and editing .","title":"Accessing and editing list elements"},{"location":"17_lists/#namespace-generic-collections","text":"To work with lists in C#, we need to include a namespace in our code. Just add the line: using System.Collections.Generic; This references generic collections , a group of classes to which the list class belongs. Note: Dictionaries are also a class belonging to generic collections.","title":"Namespace generic collections"},{"location":"17_lists/#generic-collections","text":"Generic collections are data structures that are defined without specifying a type. Only upon creation of an instance, the type of the collection is defined ( List<string> vs List<double> ). The formal class name of lists is List<T> for this reason. Note: Even though arrays are not generic collections, there also isn't a separate class for every array type (only System.Array )","title":"Generic collections"},{"location":"17_lists/#lists-are-dynamic","text":"Lists are basically the dynamic version of arrays, we can add/remove one or more elements to/from the list using methods. The indexes change when list elements are removed and added. Note: To avoid errors for trying to access index values that do not exist, you can find the max index value of a list x at a given moment by calling x.Count-1 . Method Description x.Add(elementA) Add one element, elementA to the list x.Remove(elementA) Remove one element, elementA from the list. Returns a boolean to indicate if this was successful x.AddRange(new T[] {elementA, elementB,...}) * Add multiple elements, e.g. elementA and elementB to the list x.InsertRange(ind, new T[] {elementA, elementB,...}) * Add multiple elements, e.g. elementA and elementB to the list at (not after!) the index specified by ind x.RemoveRange(new T[] {elementA, elementB,...}) * Remove multiple elements, e.g. elementA and elementB to the list x.GetRange(ind, count) Returns a list containing count elements from list x starting from index ind x.Clear() Remove all elements from the list, the count also changes Note: The AddRange() and RemoveRange() list methods accept any IEnumerable type. This includes lists, dictionaries, hashsets, queues, arrays...","title":"Lists are dynamic"},{"location":"17_lists/#other-built-in-properties-and-methods","text":"Property/method Description x.Count Returns the number of elements in the list* x.Contains(elementA) Returns a boolean, true is the element, elementA is a member of the list x.Reverse() Reverses the order of the elements in the list x.Reverse(ind, count) Overload of x.Reverse() where you specify what portion of the list to reverse, count elements starting from ind Note: For the number of elements in an array or string, we use .Length . For Lists we use .Count , this distinction stresses the difference between fixed length types and flexible types that must be counted.","title":"Other built-in properties and methods"},{"location":"17_lists/#why-use-arrays","text":"Lists actually use arrays under the hood, copying all members to a new array with the modified length whenever necessary. Therefore, using an array is faster and makes more sense when you have a fixed number of elements.","title":"Why use arrays?"},{"location":"18_LINQ/","text":"LINQ LINQ stands for Language Integrated Query and is a C# (add-on) feature that provides a query syntax to use in C# scripts to retrieve and manipulate data from data sources (databases, XML files...). LINQ Namespace LINQ queries return type Var variables Queries Query syntax Method syntax Where() Select() Query vs Method syntax LINQ with other data structures Namespace System.Linq is the namespace that we need to include in our .cs file if we want to use LINQ: using System.Linq; LINQ queries return type LINQ queries return either a single value or an object of type IEnumerable[T] . The length of IEnumerable[T] objects can be assessed with x.Count() , and we can use foreach loops on them. Note: Count() is a method that is available thanks to the namespace System.Linq , don't confuse it with the Count property of Lists . Var variables When we write a LINQ query, we usually save the result in a variable. However, we might not always be sure of the return type. How do we initialize the variable without a type in C#? The solution is the var keyword, it indicates that the C# compiler should determine the type of the variable. Queries The same LINQ query can be written in either Query syntax or Method syntax. Since where/Where() and select/Select() can be used either as keywords or as methods, we simply call them operators in the context of LINQ Query syntax Query syntax looks similar to SQL and is usually a multi-line statement. They are from - where - select statements, or from - select statements. Only where is optional. Lets look at each part separately with an example: var longNames = from name in names where name.Length > 10 select name.ToUpper(); from iterates over the elements of the data structure where assesses a condition for each member, and filters elements that meet the condition select determines what is returned for each (filtered) element, can be just the element or a transformed element Method syntax Method syntax looks more similar to regular C#, and is a method call. LINQ Methods can be chained in one statement. Where() The Where() method: var longNames = names.Where(n => n.Length > 10); Where() takes a lambda expression to assess each element of the data structure against a condition. Each element for which true is returned is added to the new collection. Select() The Select() method is used when we want to transform elements of a data structure. It can be all elements or elements filtered by the Where() method: // select to transform all elements in a data structure var upperNames = names .Select(n => n.ToUpper()); // filter some elements and then select to transform them var longUpperNames = names .Where(n => n.Length > 10) .Select(n => n.ToUpper()); Select() takes a lambda expression. Query vs Method syntax The rule of thumb is to use Method syntax for single-operator queries and Query syntax for all other queries. LINQ with other data structures We can use LINQ for arrays, but also for lists. The syntax is the same. Basically, any type that supports foreach loops can be used.","title":"LINQ"},{"location":"18_LINQ/#linq","text":"LINQ stands for Language Integrated Query and is a C# (add-on) feature that provides a query syntax to use in C# scripts to retrieve and manipulate data from data sources (databases, XML files...). LINQ Namespace LINQ queries return type Var variables Queries Query syntax Method syntax Where() Select() Query vs Method syntax LINQ with other data structures","title":"LINQ"},{"location":"18_LINQ/#namespace","text":"System.Linq is the namespace that we need to include in our .cs file if we want to use LINQ: using System.Linq;","title":"Namespace"},{"location":"18_LINQ/#linq-queries","text":"","title":"LINQ queries"},{"location":"18_LINQ/#return-type","text":"LINQ queries return either a single value or an object of type IEnumerable[T] . The length of IEnumerable[T] objects can be assessed with x.Count() , and we can use foreach loops on them. Note: Count() is a method that is available thanks to the namespace System.Linq , don't confuse it with the Count property of Lists .","title":"return type"},{"location":"18_LINQ/#var-variables","text":"When we write a LINQ query, we usually save the result in a variable. However, we might not always be sure of the return type. How do we initialize the variable without a type in C#? The solution is the var keyword, it indicates that the C# compiler should determine the type of the variable.","title":"Var variables"},{"location":"18_LINQ/#queries","text":"The same LINQ query can be written in either Query syntax or Method syntax. Since where/Where() and select/Select() can be used either as keywords or as methods, we simply call them operators in the context of LINQ","title":"Queries"},{"location":"18_LINQ/#query-syntax","text":"Query syntax looks similar to SQL and is usually a multi-line statement. They are from - where - select statements, or from - select statements. Only where is optional. Lets look at each part separately with an example: var longNames = from name in names where name.Length > 10 select name.ToUpper(); from iterates over the elements of the data structure where assesses a condition for each member, and filters elements that meet the condition select determines what is returned for each (filtered) element, can be just the element or a transformed element","title":"Query syntax"},{"location":"18_LINQ/#method-syntax","text":"Method syntax looks more similar to regular C#, and is a method call. LINQ Methods can be chained in one statement.","title":"Method syntax"},{"location":"18_LINQ/#where","text":"The Where() method: var longNames = names.Where(n => n.Length > 10); Where() takes a lambda expression to assess each element of the data structure against a condition. Each element for which true is returned is added to the new collection.","title":"Where()"},{"location":"18_LINQ/#select","text":"The Select() method is used when we want to transform elements of a data structure. It can be all elements or elements filtered by the Where() method: // select to transform all elements in a data structure var upperNames = names .Select(n => n.ToUpper()); // filter some elements and then select to transform them var longUpperNames = names .Where(n => n.Length > 10) .Select(n => n.ToUpper()); Select() takes a lambda expression.","title":"Select()"},{"location":"18_LINQ/#query-vs-method-syntax","text":"The rule of thumb is to use Method syntax for single-operator queries and Query syntax for all other queries.","title":"Query vs Method syntax"},{"location":"18_LINQ/#linq-with-other-data-structures","text":"We can use LINQ for arrays, but also for lists. The syntax is the same. Basically, any type that supports foreach loops can be used.","title":"LINQ with other data structures"},{"location":"2_data_types/","text":"C# data types C# data types Data type conversion Implicit conversion Explicit conversion Conversion using methods Data type description example int whole numbers int intNum = 3; float decimal numbers with less precision (+/- 7 digits) float floatNum = 3.14f; double decimal numbers with double precision (+/- 15 digits) double doubleNum = 3.14; decimal decimal number with the heighest precision (+/- 28 digits) decimal decimalNum = 3.14d; char single characters char randomChar = \"g\"; string string of characters string randomString = \"goodday\"; bool boolean value bool boolValue = true; Note: How do you choose a data type for numerical data? If you don't need much precision consider using a float or int instead of a double or decimal, they take up less memory and result in a faster program! Data type conversion Implicit conversion Some data types can be converted into each other implicitly. This is done by declaring the new variable of type x and simply assigning the existing variable for type y to it. However, this is only possible when no data will be lost in the conversion (double can implicitly be converted to int but not the other way around). Example: int length = 2; double lengthDouble = length; Explicit conversion For data types that cannot be implicitly converted because data would be lost, you can use a cast operation . Hereby, you accept that you will lose precision. The syntax is: type variable = (type)variableToConvert; Example: double length = 2.22; int lengthInt = (int)length; Note: You can explicitly convert a variable of type char into a variable of type int and vice versa, because characters have ASCII codes which are integers. Conversion using methods There are also built-in methods that can be used for conversions that are not implicitly or explicitly possible, (like integer to string and the other way around). For example: string numberString = \"33\"; int number = Convert.ToInt32(numberString); // or: int number = Int.Parse(numberString); or int number = 33; string numberString = number.ToString(); Notice that the syntax is slightly different for string to int than for int to string.","title":"Data types"},{"location":"2_data_types/#c-data-types","text":"C# data types Data type conversion Implicit conversion Explicit conversion Conversion using methods Data type description example int whole numbers int intNum = 3; float decimal numbers with less precision (+/- 7 digits) float floatNum = 3.14f; double decimal numbers with double precision (+/- 15 digits) double doubleNum = 3.14; decimal decimal number with the heighest precision (+/- 28 digits) decimal decimalNum = 3.14d; char single characters char randomChar = \"g\"; string string of characters string randomString = \"goodday\"; bool boolean value bool boolValue = true; Note: How do you choose a data type for numerical data? If you don't need much precision consider using a float or int instead of a double or decimal, they take up less memory and result in a faster program!","title":"C# data types"},{"location":"2_data_types/#data-type-conversion","text":"","title":"Data type conversion"},{"location":"2_data_types/#implicit-conversion","text":"Some data types can be converted into each other implicitly. This is done by declaring the new variable of type x and simply assigning the existing variable for type y to it. However, this is only possible when no data will be lost in the conversion (double can implicitly be converted to int but not the other way around). Example: int length = 2; double lengthDouble = length;","title":"Implicit conversion"},{"location":"2_data_types/#explicit-conversion","text":"For data types that cannot be implicitly converted because data would be lost, you can use a cast operation . Hereby, you accept that you will lose precision. The syntax is: type variable = (type)variableToConvert; Example: double length = 2.22; int lengthInt = (int)length; Note: You can explicitly convert a variable of type char into a variable of type int and vice versa, because characters have ASCII codes which are integers.","title":"Explicit conversion"},{"location":"2_data_types/#conversion-using-methods","text":"There are also built-in methods that can be used for conversions that are not implicitly or explicitly possible, (like integer to string and the other way around). For example: string numberString = \"33\"; int number = Convert.ToInt32(numberString); // or: int number = Int.Parse(numberString); or int number = 33; string numberString = number.ToString(); Notice that the syntax is slightly different for string to int than for int to string.","title":"Conversion using methods"},{"location":"3_arithmetic_operations/","text":"Arithmetic operations Arithmetic operations Simple operations shortcuts for addition and subtraction Complex operations Simple operations additions: \"+\" subtraction: \"-\" multiplication: \"*\" division: \"/\" modulo: \"%\" (what remains after division \"rest\") Notes: - Arithmetic operations with integers results in integers, arithmetic operations with an integer and a double result in a double. We don't lose precision. - Use parentheses to indicate the order of operations as good practice. - Modulo can be used to check wether a number is odd or even. Just take its modulo with \"2\"; if the answer is zero the number was even, if the answer is one the number was odd. shortcuts for addition and subtraction Long form Short form apple = apple + 1; apple++; apple = apple - 1; apple--; apple = apple + 5; apple+= 5; apple = apple - 5; apple-= 5; Complex operations For more complex mathematic operations, we can't use keyboard symbols. Instead, we use built-in methods . A lot of these are methods of the \"Math\" class: Method Description Math.Abs() absolute value Math.Sqrt() square root Math.Floor() rounds down to a whole number Math.Min() returns smallest of two numbers Math.Pow(x,y) result of number x to the power of y Math.Max() returns largest of two numbers Math.Ceiling() rounds up to a whole number Note: When you use methods like these, you can always check their documentation to see how to use them or for any restrictions. e.g. Math.Sqrt only takes positive numbers!","title":"Arithmetic operations"},{"location":"3_arithmetic_operations/#arithmetic-operations","text":"Arithmetic operations Simple operations shortcuts for addition and subtraction Complex operations","title":"Arithmetic operations"},{"location":"3_arithmetic_operations/#simple-operations","text":"additions: \"+\" subtraction: \"-\" multiplication: \"*\" division: \"/\" modulo: \"%\" (what remains after division \"rest\") Notes: - Arithmetic operations with integers results in integers, arithmetic operations with an integer and a double result in a double. We don't lose precision. - Use parentheses to indicate the order of operations as good practice. - Modulo can be used to check wether a number is odd or even. Just take its modulo with \"2\"; if the answer is zero the number was even, if the answer is one the number was odd.","title":"Simple operations"},{"location":"3_arithmetic_operations/#shortcuts-for-addition-and-subtraction","text":"Long form Short form apple = apple + 1; apple++; apple = apple - 1; apple--; apple = apple + 5; apple+= 5; apple = apple - 5; apple-= 5;","title":"shortcuts for addition and subtraction"},{"location":"3_arithmetic_operations/#complex-operations","text":"For more complex mathematic operations, we can't use keyboard symbols. Instead, we use built-in methods . A lot of these are methods of the \"Math\" class: Method Description Math.Abs() absolute value Math.Sqrt() square root Math.Floor() rounds down to a whole number Math.Min() returns smallest of two numbers Math.Pow(x,y) result of number x to the power of y Math.Max() returns largest of two numbers Math.Ceiling() rounds up to a whole number Note: When you use methods like these, you can always check their documentation to see how to use them or for any restrictions. e.g. Math.Sqrt only takes positive numbers!","title":"Complex operations"},{"location":"4_working_with_text/","text":"Working with text Working with text Escape sequences in strings String concatenation String interpolation String properties and methods Bracket notation Escape sequences in strings Escape sequence Description \\ \" \\ \" quotation marks in string \\n line break in string String concatenation Combine strings or strings and variables using string concatenation: Console.WriteLine(\"string1\" + variable1 + \"string2\" + \".\"); Note: If you concatenate a string with a variable of another type, it will automatically convert that variable to a string. String interpolation If you want to combine variables and string text without having to use plus signs all the time, you can use string interpolation: Console.WriteLine($\"Hello, my name is {name}. I am {age} years old.\") Note: If you interpolate a string with a variable of another type, it will automatically convert that variable to a string. String properties and methods Properties (e.g. Length) request data and we use string.Property as syntax, methods perform actions or computations and we use string.Method() as syntax. Property Description .Length returns the number of characters of a string Method Description .IndexOf(x) returns the index (position starting from 0) of the first char of substring x returns \"-1\" if the substring does not exist within the string .Substring(x, y) returns a substring starting from position x in the original string if y is specified, the substring will be y characters long .ToUpper() convert string to uppercase .ToLower() convert string to lowercase Note: - When you use methods like these, you can always check their documentation to see how to use them or for any restrictions. - The first character in a string has index 0. So the position 0 is the first character and position 1 is the second character. Bracket notation To find the character at a certain position of a string, we use bracket notation. (This is similar to how you access values in an array): string[0] returns the first character string[1] returns the second character Note: In C# you can NOT use the index -1 to retrieve the last character of the string.","title":"Working with text"},{"location":"4_working_with_text/#working-with-text","text":"Working with text Escape sequences in strings String concatenation String interpolation String properties and methods Bracket notation","title":"Working with text"},{"location":"4_working_with_text/#escape-sequences-in-strings","text":"Escape sequence Description \\ \" \\ \" quotation marks in string \\n line break in string","title":"Escape sequences in strings"},{"location":"4_working_with_text/#string-concatenation","text":"Combine strings or strings and variables using string concatenation: Console.WriteLine(\"string1\" + variable1 + \"string2\" + \".\"); Note: If you concatenate a string with a variable of another type, it will automatically convert that variable to a string.","title":"String concatenation"},{"location":"4_working_with_text/#string-interpolation","text":"If you want to combine variables and string text without having to use plus signs all the time, you can use string interpolation: Console.WriteLine($\"Hello, my name is {name}. I am {age} years old.\") Note: If you interpolate a string with a variable of another type, it will automatically convert that variable to a string.","title":"String interpolation"},{"location":"4_working_with_text/#string-properties-and-methods","text":"Properties (e.g. Length) request data and we use string.Property as syntax, methods perform actions or computations and we use string.Method() as syntax. Property Description .Length returns the number of characters of a string Method Description .IndexOf(x) returns the index (position starting from 0) of the first char of substring x returns \"-1\" if the substring does not exist within the string .Substring(x, y) returns a substring starting from position x in the original string if y is specified, the substring will be y characters long .ToUpper() convert string to uppercase .ToLower() convert string to lowercase Note: - When you use methods like these, you can always check their documentation to see how to use them or for any restrictions. - The first character in a string has index 0. So the position 0 is the first character and position 1 is the second character.","title":"String properties and methods"},{"location":"4_working_with_text/#bracket-notation","text":"To find the character at a certain position of a string, we use bracket notation. (This is similar to how you access values in an array): string[0] returns the first character string[1] returns the second character Note: In C# you can NOT use the index -1 to retrieve the last character of the string.","title":"Bracket notation"},{"location":"5_boolean/","text":"Boolean data type The boolean data type can take the values true and false , these are binaries. The boolean values are not strings. Boolean data type Boolean expressions Comparison operators Logical operators (aka boolean operators) Boolean expressions Boolean expressions are expressions that return a boolean value (or in other words evaluate to a boolean). They contain comparison operators and/or logical operators . You can declare a boolean variable as a boolean expression, the return value will be a boolean. Boolean expressions can evaluate integers, doubles, strings, variables, and even booleans. Comparison operators Comparison operator Description == evaluates whether the two sides of the expression are equal != evaluates whether the two sides of the expression are not equal > evaluates whether the left side is greater than the right side < evaluates whether the left side is smaller than the right side >= evaluates whether the left side is greater than or equal to the right side <= evaluates whether the left side is smaller than or equal to the right side Logical operators (aka boolean operators) Logical operators can appear in boolean expressions. They take boolean values as input and as output. You can chain multiple logical statements in one boolean expression. Logical operator Name Description AND && true if both sides evaluate to true OR II true if one or two sides evaluate to true NOT ! true if evaluates to false, false if evaluates to true Note: ! comes in the beginning of the expression. AND and OR come in between the two sides of the expression. example of a boolean exercise I did: using System; namespace Review { class Program { static void Main(string[] args) { // Password declaration string password = \"abc!de\"; // Check whether there is an uppercase character bool upperCheckChar = false; bool upperCheck = false; // Check if there are no symbols bool symbolCheckChar = false; bool symbolCheck = false; foreach (char i in password) { upperCheckChar = (i == Char.ToUpper(i)); if (upperCheckChar) { upperCheck = true; break; } symbolCheckChar = ((i == Convert.ToChar(\"!\")) || (i == Convert.ToChar(\"?\")) || (i == Convert.ToChar(\".\")) || (i == Convert.ToChar(\"@\")) || (i == Convert.ToChar(\"#\"))); if (symbolCheckChar) { symbolCheck = true; break; } } Console.WriteLine($\"Contains uppercase letter: {upperCheck}\"); Console.WriteLine($\"Contains symbol: {symbolCheck}\"); // Check validity of password bool passwordCheck = (upperCheck && !symbolCheck); Console.WriteLine($\"Password OK: {passwordCheck}\"); } } }","title":"Booleans"},{"location":"5_boolean/#boolean-data-type","text":"The boolean data type can take the values true and false , these are binaries. The boolean values are not strings. Boolean data type Boolean expressions Comparison operators Logical operators (aka boolean operators)","title":"Boolean data type"},{"location":"5_boolean/#boolean-expressions","text":"Boolean expressions are expressions that return a boolean value (or in other words evaluate to a boolean). They contain comparison operators and/or logical operators . You can declare a boolean variable as a boolean expression, the return value will be a boolean. Boolean expressions can evaluate integers, doubles, strings, variables, and even booleans.","title":"Boolean expressions"},{"location":"5_boolean/#comparison-operators","text":"Comparison operator Description == evaluates whether the two sides of the expression are equal != evaluates whether the two sides of the expression are not equal > evaluates whether the left side is greater than the right side < evaluates whether the left side is smaller than the right side >= evaluates whether the left side is greater than or equal to the right side <= evaluates whether the left side is smaller than or equal to the right side","title":"Comparison operators"},{"location":"5_boolean/#logical-operators-aka-boolean-operators","text":"Logical operators can appear in boolean expressions. They take boolean values as input and as output. You can chain multiple logical statements in one boolean expression. Logical operator Name Description AND && true if both sides evaluate to true OR II true if one or two sides evaluate to true NOT ! true if evaluates to false, false if evaluates to true Note: ! comes in the beginning of the expression. AND and OR come in between the two sides of the expression. example of a boolean exercise I did: using System; namespace Review { class Program { static void Main(string[] args) { // Password declaration string password = \"abc!de\"; // Check whether there is an uppercase character bool upperCheckChar = false; bool upperCheck = false; // Check if there are no symbols bool symbolCheckChar = false; bool symbolCheck = false; foreach (char i in password) { upperCheckChar = (i == Char.ToUpper(i)); if (upperCheckChar) { upperCheck = true; break; } symbolCheckChar = ((i == Convert.ToChar(\"!\")) || (i == Convert.ToChar(\"?\")) || (i == Convert.ToChar(\".\")) || (i == Convert.ToChar(\"@\")) || (i == Convert.ToChar(\"#\"))); if (symbolCheckChar) { symbolCheck = true; break; } } Console.WriteLine($\"Contains uppercase letter: {upperCheck}\"); Console.WriteLine($\"Contains symbol: {symbolCheck}\"); // Check validity of password bool passwordCheck = (upperCheck && !symbolCheck); Console.WriteLine($\"Password OK: {passwordCheck}\"); } } }","title":"Logical operators (aka boolean operators)"},{"location":"6_conditional_statements/","text":"Conditional statements Conditional statements Types of conditional statements if statements if/else statements else if statements switch statements switch statement example switch statement example with conditions (advanced) Ternary operators Example of ternary operators Note: Familiarize yourself with boolean expressions before you dig into this topic. Types of conditional statements if statements if/else statements else if statements switch statements Ternary operations: ? if statements If statements are conditional statements that execute a block of code if the condition is true. Otherwise, the code block is skipped. if (boolean expression) { execute this code; } if/else statements It is an extension of the if statement, we add an else and a block of code that is executed if the if condition is false. if (boolean expression) { execute this code; } else { execute this code; } Note: if/else is one statement, so don't put a semicolon after the if statement if you want to add an else! else if statements If you want to handle more than two possible scenario's an if/else statement won't be enough. For chaining if statements, use else if 's. Remarks: You can use as many else if 's as you want You can still end with en else statement to capture any unmatched conditions, but you don't have to You don't put semicolons in between the statements because they are one statement. if (boolean expression) { execute this code; } else if (boolean expression) { execute this code; } else if (boolean expression) { execute this code; } else { execute this code; } switch statements When you have a lot of different values of a variable to check (I would say >3) you can avoid the repetition of the else if codeblock by using switch statements. Note: Switch statements are not well-suited for conditional expressions. Use else if in that case. Every case has a break statement that allows you to exit the switch statement after a case has been matched and the relevant code executed. Every switch statement has a default statement that captures those instances that do not match a case. switch(variable that is addressed) { case \"enter condition\": execute this code; break; case \"enter condition\": execute this code; break; default: execute this code: break; } switch statement example Console.WriteLine(\"Please choose a movie genre.\"); string genre = Console.ReadLine(); switch (genre) { case \"Horror\": Console.WriteLine(\"Psycho\"); break; case \"Drama\": Console.WriteLine(\"Citizen Kane\"); break; case \"Comedy\": Console.WriteLine(\"Duck Soup\"); break; case \"Adventure\": Console.WriteLine(\"King Kong\"); break; case \"Science Fiction\": Console.WriteLine(\"2001: A Space Odyssey\"); break; default: Console.WriteLine(\"No movie found\"); break; } switch statement example with conditions (advanced) int number = 6; int guess = 0; Console.WriteLine(\"Guess a number between 1 and 10.\"); while (guess != 6) { guess = Convert.ToInt32(Console.ReadLine()); switch (guess) { case int n when n == number: Console.WriteLine(\"Congratulations! You guessed it.\"); break; case int n when ((n > number) && !(n > 10)): Console.WriteLine(\"That's too high!\"); break; case int n when ((n < number) && !(n < 1)): Console.WriteLine(\"That's too low!\"); break; default: Console.WriteLine(\"That's not a number between 1 and 10..\"); break; } } Ternary operators When you need to make a binary decision (two possible conditions) you can use a ternary operator ( ? ) instead of the if/else statement. It has shorter syntax but is less readable. string result = (conditional expression) ? \"value of result when true\" : \"value of result when false\" Example of ternary operators int pepperLength = 4; string message = (pepperLength >= 3.5) ? \"ready!\":\"wait a little longer\"; Console.WriteLine(message);","title":"Conditional statements"},{"location":"6_conditional_statements/#conditional-statements","text":"Conditional statements Types of conditional statements if statements if/else statements else if statements switch statements switch statement example switch statement example with conditions (advanced) Ternary operators Example of ternary operators Note: Familiarize yourself with boolean expressions before you dig into this topic.","title":"Conditional statements"},{"location":"6_conditional_statements/#types-of-conditional-statements","text":"if statements if/else statements else if statements switch statements Ternary operations: ?","title":"Types of conditional statements"},{"location":"6_conditional_statements/#if-statements","text":"If statements are conditional statements that execute a block of code if the condition is true. Otherwise, the code block is skipped. if (boolean expression) { execute this code; }","title":"if statements"},{"location":"6_conditional_statements/#ifelse-statements","text":"It is an extension of the if statement, we add an else and a block of code that is executed if the if condition is false. if (boolean expression) { execute this code; } else { execute this code; } Note: if/else is one statement, so don't put a semicolon after the if statement if you want to add an else!","title":"if/else statements"},{"location":"6_conditional_statements/#else-if-statements","text":"If you want to handle more than two possible scenario's an if/else statement won't be enough. For chaining if statements, use else if 's. Remarks: You can use as many else if 's as you want You can still end with en else statement to capture any unmatched conditions, but you don't have to You don't put semicolons in between the statements because they are one statement. if (boolean expression) { execute this code; } else if (boolean expression) { execute this code; } else if (boolean expression) { execute this code; } else { execute this code; }","title":"else if statements"},{"location":"6_conditional_statements/#switch-statements","text":"When you have a lot of different values of a variable to check (I would say >3) you can avoid the repetition of the else if codeblock by using switch statements. Note: Switch statements are not well-suited for conditional expressions. Use else if in that case. Every case has a break statement that allows you to exit the switch statement after a case has been matched and the relevant code executed. Every switch statement has a default statement that captures those instances that do not match a case. switch(variable that is addressed) { case \"enter condition\": execute this code; break; case \"enter condition\": execute this code; break; default: execute this code: break; }","title":"switch statements"},{"location":"6_conditional_statements/#switch-statement-example","text":"Console.WriteLine(\"Please choose a movie genre.\"); string genre = Console.ReadLine(); switch (genre) { case \"Horror\": Console.WriteLine(\"Psycho\"); break; case \"Drama\": Console.WriteLine(\"Citizen Kane\"); break; case \"Comedy\": Console.WriteLine(\"Duck Soup\"); break; case \"Adventure\": Console.WriteLine(\"King Kong\"); break; case \"Science Fiction\": Console.WriteLine(\"2001: A Space Odyssey\"); break; default: Console.WriteLine(\"No movie found\"); break; }","title":"switch statement example"},{"location":"6_conditional_statements/#switch-statement-example-with-conditions-advanced","text":"int number = 6; int guess = 0; Console.WriteLine(\"Guess a number between 1 and 10.\"); while (guess != 6) { guess = Convert.ToInt32(Console.ReadLine()); switch (guess) { case int n when n == number: Console.WriteLine(\"Congratulations! You guessed it.\"); break; case int n when ((n > number) && !(n > 10)): Console.WriteLine(\"That's too high!\"); break; case int n when ((n < number) && !(n < 1)): Console.WriteLine(\"That's too low!\"); break; default: Console.WriteLine(\"That's not a number between 1 and 10..\"); break; } }","title":"switch statement example with conditions (advanced)"},{"location":"6_conditional_statements/#ternary-operators","text":"When you need to make a binary decision (two possible conditions) you can use a ternary operator ( ? ) instead of the if/else statement. It has shorter syntax but is less readable. string result = (conditional expression) ? \"value of result when true\" : \"value of result when false\"","title":"Ternary operators"},{"location":"6_conditional_statements/#example-of-ternary-operators","text":"int pepperLength = 4; string message = (pepperLength >= 3.5) ? \"ready!\":\"wait a little longer\"; Console.WriteLine(message);","title":"Example of ternary operators"},{"location":"7_methods/","text":"Methods Methods are reusable sets of instructions to perform a certain task. Some methods are built-in to C#, but you can also define your own. Methods Calling a method Input: arguments Capturing method output Chaining methods Creating a new method Method parameters Calling a method with arguments in a different order Method overloading Method output Return Out Method declaration with out Method calling with out Methods as method arguments Static vs instance methods Static methods Instance methods Calling a method You can call a method by writing the method's name and adding parentheses. e.g. Console.WriteLine(); Input: arguments arguments are input you can provide to some methods. Arguments are provided in the parentheses when calling a method. e.g. Console.WriteLine(\"hello\"); The argument of this method is the string \"hello\" When there is more than one argument, use comma's to separate them. e.g. Math.Min(3,5) Capturing method output Some methods return a value, how can you capture this output? You can do this using a variable e.g. int minNumber = Math.Min(2,5); Chaining methods You can chain multiple methods. The innermost method returns a value that is used as the input for the outer method. e.g. Console.WriteLine(\"hello\".Substring(2,2)); Creating a new method Methods in C# have PascalCase names. The syntax for method definitions looks like this: static void MyMethod() { Code block that is executed when you call the method; } In C# the code that your program runs is encapsulated in the Main method. All other method definitions, should be placed outside of the definition of Main() . static void MyMethod() This part is the method declaration . It consists of: - an access modifier (public, private) - optional keywords (like static ) - a return type (void, meaning that nothing is returned) - a name (MyMethod). Note: - Sometimes no access modifier is specified, within a class the default is private and within an interface it is always public . - Sometimes no return type is needed (e.g. the constructor method of a class) Method parameters To allow your own methods to accept input arguments, we need to define placeholders for those arguments and instruct the method what to do with them. These argument placeholders are called parameters. The syntax looks like this (of course the method could contain any code): static void MyMethod(string myFirstParameter, int mySecondParameter = 0) { Console.WriteLine(myFirstParameter, mySecondParameters); } When there is more than one parameter, they are separated by a comma When you want a parameter to be optional use = and a default value (if you don't do this you will get errors when calling the method because you did not define a parameter) Note: Parameters can only be used within the scope of their methods, because they are not defined outside of the method. Calling a method with arguments in a different order Arguments are passed to methods in the order the parameters are defined. You might get in trouble when a method has multiple optional parameters, and you want to pass an argument of the third parameter only. To fix this problem, you can name your arguments with the parameter name. In that case, the order does not matter anymore. Example: static void MyMethod( int myFirstP = 0, int mySecondP = 1, int myThirdP = 2, int myForthP = 3) { ... } static void Main() { MyMethod(myThirdP: 3, myFirstP: 2); } Method overloading Method overloading is a term used for when there are several methods with the same name but different parameters or a different number of parameters. This is useful if you want the same method to have different behavior based on its inputs. A method signature or declaration, on the other hand, is unique. It is the combination of the method name, its parameters and their order. Method output Method declarations contain the return type of their output. Void means there is no output value. If a method returns a type different from the stated return type, it will throw an error. Return Return is a keyword that is used in method code to allow it to return a value or variable. When return is used in a method, you must specify the type of the returned value in the method declaration as follows: static int MyMethod() { return 1+5; } Out The return keyword only allows you to return one value. What if you want your method to return more than one value? You can use return for the first value, and the out keyword for other values. Method declaration with out You use out in a parameter, with the syntax: static string MyMethod(string name, out int age) { age = 25; } You must declare the out parameter with a type. Out can only output a variable, because otherwise we can't specify where it is stored. The out parameter ( age ) must be set to a value before the method ends (before the return statement?). Method calling with out Calling the method will return the value you tell it to return AND save a value to the variable specified after out. MyMethod(\"Virg\", out int myAge) If you didn't declare the out argument ( myAge ) in the main code, you need to specify its type when calling the method. You need to specify the out parameter both when declaring the method and when calling it. Note: Calling the method still only returns the value specified by the return keyword. If you want to access the out value, you will have to use the out variable after calling the method. Methods as method arguments Some methods accept other methods as arguments, this method is then called one or more times in the body of the function using the argument (method name) and (). The method name (or definition) is passed as an argument , not the method with parentheses, since that would mean executing it there. Example: Array.Find() returns the first array item for which the method returns 'true'. Array.Find(array1, Method1); Note: Remember that you can recognize that a method has another method as its argument by the PascalCase of methods. Static vs instance methods Static methods Static methods belong to a class and are called on that class, not on an object of the class. To call a static method, you use the class name followed by the method name: ClassName.MethodName(parameters) Example: Array.Sort(arrayX); Note: - Static methods do not require an instance of the class to be called. Think of Math.Floor() , you do not need an instance of the Math class to call it. - The methods we define in our Program e.g. MyMethod(), are often static methods on the Program class. Because we are using the methods IN the Program class we don't need to specify the class name Program.MyMethod(), but we can shorten it to MyMethod(). Note: Please refer to the documentation on classes to read more about static class members. Instance methods Instance methods belong to instances of a class, not the class itself. To call an instance method, you use the instance name followed by the method name: instanceName.MethodName(parameters); Example: stringX.subString(\"a\", 3);","title":"Methods"},{"location":"7_methods/#methods","text":"Methods are reusable sets of instructions to perform a certain task. Some methods are built-in to C#, but you can also define your own. Methods Calling a method Input: arguments Capturing method output Chaining methods Creating a new method Method parameters Calling a method with arguments in a different order Method overloading Method output Return Out Method declaration with out Method calling with out Methods as method arguments Static vs instance methods Static methods Instance methods","title":"Methods"},{"location":"7_methods/#calling-a-method","text":"You can call a method by writing the method's name and adding parentheses. e.g. Console.WriteLine();","title":"Calling a method"},{"location":"7_methods/#input-arguments","text":"arguments are input you can provide to some methods. Arguments are provided in the parentheses when calling a method. e.g. Console.WriteLine(\"hello\"); The argument of this method is the string \"hello\" When there is more than one argument, use comma's to separate them. e.g. Math.Min(3,5)","title":"Input: arguments"},{"location":"7_methods/#capturing-method-output","text":"Some methods return a value, how can you capture this output? You can do this using a variable e.g. int minNumber = Math.Min(2,5);","title":"Capturing method output"},{"location":"7_methods/#chaining-methods","text":"You can chain multiple methods. The innermost method returns a value that is used as the input for the outer method. e.g. Console.WriteLine(\"hello\".Substring(2,2));","title":"Chaining methods"},{"location":"7_methods/#creating-a-new-method","text":"Methods in C# have PascalCase names. The syntax for method definitions looks like this: static void MyMethod() { Code block that is executed when you call the method; } In C# the code that your program runs is encapsulated in the Main method. All other method definitions, should be placed outside of the definition of Main() . static void MyMethod() This part is the method declaration . It consists of: - an access modifier (public, private) - optional keywords (like static ) - a return type (void, meaning that nothing is returned) - a name (MyMethod). Note: - Sometimes no access modifier is specified, within a class the default is private and within an interface it is always public . - Sometimes no return type is needed (e.g. the constructor method of a class)","title":"Creating a new method"},{"location":"7_methods/#method-parameters","text":"To allow your own methods to accept input arguments, we need to define placeholders for those arguments and instruct the method what to do with them. These argument placeholders are called parameters. The syntax looks like this (of course the method could contain any code): static void MyMethod(string myFirstParameter, int mySecondParameter = 0) { Console.WriteLine(myFirstParameter, mySecondParameters); } When there is more than one parameter, they are separated by a comma When you want a parameter to be optional use = and a default value (if you don't do this you will get errors when calling the method because you did not define a parameter) Note: Parameters can only be used within the scope of their methods, because they are not defined outside of the method.","title":"Method parameters"},{"location":"7_methods/#calling-a-method-with-arguments-in-a-different-order","text":"Arguments are passed to methods in the order the parameters are defined. You might get in trouble when a method has multiple optional parameters, and you want to pass an argument of the third parameter only. To fix this problem, you can name your arguments with the parameter name. In that case, the order does not matter anymore. Example: static void MyMethod( int myFirstP = 0, int mySecondP = 1, int myThirdP = 2, int myForthP = 3) { ... } static void Main() { MyMethod(myThirdP: 3, myFirstP: 2); }","title":"Calling a method with arguments in a different order"},{"location":"7_methods/#method-overloading","text":"Method overloading is a term used for when there are several methods with the same name but different parameters or a different number of parameters. This is useful if you want the same method to have different behavior based on its inputs. A method signature or declaration, on the other hand, is unique. It is the combination of the method name, its parameters and their order.","title":"Method overloading"},{"location":"7_methods/#method-output","text":"Method declarations contain the return type of their output. Void means there is no output value. If a method returns a type different from the stated return type, it will throw an error.","title":"Method output"},{"location":"7_methods/#return","text":"Return is a keyword that is used in method code to allow it to return a value or variable. When return is used in a method, you must specify the type of the returned value in the method declaration as follows: static int MyMethod() { return 1+5; }","title":"Return"},{"location":"7_methods/#out","text":"The return keyword only allows you to return one value. What if you want your method to return more than one value? You can use return for the first value, and the out keyword for other values.","title":"Out"},{"location":"7_methods/#method-declaration-with-out","text":"You use out in a parameter, with the syntax: static string MyMethod(string name, out int age) { age = 25; } You must declare the out parameter with a type. Out can only output a variable, because otherwise we can't specify where it is stored. The out parameter ( age ) must be set to a value before the method ends (before the return statement?).","title":"Method declaration with out"},{"location":"7_methods/#method-calling-with-out","text":"Calling the method will return the value you tell it to return AND save a value to the variable specified after out. MyMethod(\"Virg\", out int myAge) If you didn't declare the out argument ( myAge ) in the main code, you need to specify its type when calling the method. You need to specify the out parameter both when declaring the method and when calling it. Note: Calling the method still only returns the value specified by the return keyword. If you want to access the out value, you will have to use the out variable after calling the method.","title":"Method calling with out"},{"location":"7_methods/#methods-as-method-arguments","text":"Some methods accept other methods as arguments, this method is then called one or more times in the body of the function using the argument (method name) and (). The method name (or definition) is passed as an argument , not the method with parentheses, since that would mean executing it there. Example: Array.Find() returns the first array item for which the method returns 'true'. Array.Find(array1, Method1); Note: Remember that you can recognize that a method has another method as its argument by the PascalCase of methods.","title":"Methods as method arguments"},{"location":"7_methods/#static-vs-instance-methods","text":"","title":"Static vs instance methods"},{"location":"7_methods/#static-methods","text":"Static methods belong to a class and are called on that class, not on an object of the class. To call a static method, you use the class name followed by the method name: ClassName.MethodName(parameters) Example: Array.Sort(arrayX); Note: - Static methods do not require an instance of the class to be called. Think of Math.Floor() , you do not need an instance of the Math class to call it. - The methods we define in our Program e.g. MyMethod(), are often static methods on the Program class. Because we are using the methods IN the Program class we don't need to specify the class name Program.MyMethod(), but we can shorten it to MyMethod(). Note: Please refer to the documentation on classes to read more about static class members.","title":"Static methods"},{"location":"7_methods/#instance-methods","text":"Instance methods belong to instances of a class, not the class itself. To call an instance method, you use the instance name followed by the method name: instanceName.MethodName(parameters); Example: stringX.subString(\"a\", 3);","title":"Instance methods"},{"location":"8_alternate_expressions/","text":"Alternate expressions (Method shortcuts) Alternate ways of defining a method , used mostly for short methods to reduce the amount of code. They include expression-bodied definitions and lambda expressions . Alternate expressions (Method shortcuts) Expression-bodied definitions Lambda expressions Expression-bodied definitions aka the squid notation Expression-bodied definitions are methods that contain only one expression (line) written: - without curly braces - without return keyword - with an => followed by the expression example: static string MyMethod(string input) { return input.subString(1); } static string MyMethod(string input) => input.subString(1); Lambda expressions Remember that some methods accept other methods as arguments? Your code might be difficult to read if your method definition is separated from the method that calls it. To increase readability, you can define your method directly inside signature of the method that calls it. The notation we use, is called a lambda expression. Lambda expressions are anonymous method definitions, because they have no name Note: When the method definition is long, this might worsen readability. In that case, it might be better to separate the method definition from the method that calls it. For methods with one expression: no access modifier, return type, name no curly braces no return keyword no semicolon example: // Normal method definition int[] numbers = {1,2,5,7}; static bool IsEven(int num) { return num % 2 == 0; } Array.Exists(number, IsEven); // Lambda expression int[] numbers = {1,2,5,7}; Array.Exists(numbers, (int num) => num % 2 == 0); For methods with more than one expression: no access modifier, return type, name (but curly braces, semicolons, and a return statement) example: // Normal method definition int[] numbers = {1,2,5,7}; static bool IsOk(int num) { numAbs = Math.Abs(num); return numAbs >= 5; } Array.Exists(number, IsOk); // Lambda expression int[] numbers = {1,2,5,7}; Array.Exists(numbers, (int num) => { numAbs = Math.Abs(num); return numAbs >= 5; }) Note: Further shortcuts for lambda expressions exist: - If there is only one parameter, parentheses are not needed. - If the type of the parameter is inferred from the body, you don't need to add it.","title":"Alternate expressions"},{"location":"8_alternate_expressions/#alternate-expressions-method-shortcuts","text":"Alternate ways of defining a method , used mostly for short methods to reduce the amount of code. They include expression-bodied definitions and lambda expressions . Alternate expressions (Method shortcuts) Expression-bodied definitions Lambda expressions","title":"Alternate expressions (Method shortcuts)"},{"location":"8_alternate_expressions/#expression-bodied-definitions","text":"aka the squid notation Expression-bodied definitions are methods that contain only one expression (line) written: - without curly braces - without return keyword - with an => followed by the expression example: static string MyMethod(string input) { return input.subString(1); } static string MyMethod(string input) => input.subString(1);","title":"Expression-bodied definitions"},{"location":"8_alternate_expressions/#lambda-expressions","text":"Remember that some methods accept other methods as arguments? Your code might be difficult to read if your method definition is separated from the method that calls it. To increase readability, you can define your method directly inside signature of the method that calls it. The notation we use, is called a lambda expression. Lambda expressions are anonymous method definitions, because they have no name Note: When the method definition is long, this might worsen readability. In that case, it might be better to separate the method definition from the method that calls it. For methods with one expression: no access modifier, return type, name no curly braces no return keyword no semicolon example: // Normal method definition int[] numbers = {1,2,5,7}; static bool IsEven(int num) { return num % 2 == 0; } Array.Exists(number, IsEven); // Lambda expression int[] numbers = {1,2,5,7}; Array.Exists(numbers, (int num) => num % 2 == 0); For methods with more than one expression: no access modifier, return type, name (but curly braces, semicolons, and a return statement) example: // Normal method definition int[] numbers = {1,2,5,7}; static bool IsOk(int num) { numAbs = Math.Abs(num); return numAbs >= 5; } Array.Exists(number, IsOk); // Lambda expression int[] numbers = {1,2,5,7}; Array.Exists(numbers, (int num) => { numAbs = Math.Abs(num); return numAbs >= 5; }) Note: Further shortcuts for lambda expressions exist: - If there is only one parameter, parentheses are not needed. - If the type of the parameter is inferred from the body, you don't need to add it.","title":"Lambda expressions"},{"location":"9_data_structures_arrays/","text":"Arrays Arrays are data structures . Data structures store larger amounts of information in an organized way. An array is a linear list of elements of the same data type . Each element has a specific position in the list. Did you know : A string is an array of characters. You can ask for a character using its position in the string, just like you can do with arrays. Arrays Syntax Declaring an array Initializing an array Declaring and initializing an array An empty array Built-in properties and methods Accessing array elements Array editing Printing an array Syntax Declaring an array Declare an array by declaring its type followed by square brackets: string[] arrayOfStrings; int[] arrayOfInts; double[] arrayOfDoubles; Initializing an array Initialize an array by calling a new instance of the array class. The elements of the array are separated by commas and encapsulated in curly brackets: arrayOfStrings = new string[] {\"hallo\", \"beer\", \"kijken\"}; Note: We instantiating an object from the class Array, but the syntax deviates from the standard: use type[] instead of Array . Declaring and initializing an array You can also declare and initialize the array in one step, in that case you don't need to use the new type[] syntax: string[] arrayOfStrings = {\"hallo\", \"beer\", \"kijken\"}; An empty array What is you don't know yet what the content of your array will be? You can declare an empty array as follows: string[0] arrayOfStrings = new string[8]; This array has 8 strings This array now contains null values at every position Note: Empty arrays of strings contain null as values, empty arrays of integers contain 0 as values. Built-in properties and methods Property /method Description arrayX.Length Returns the number of elements in the array Array.IndexOf(arrayX, valueX) Returns the index of valueX in arrayX Array.Sort(arrayX) Returns an array with the same elements as the input but in ascending order ( int[] , float[] ...), or alphabetical order ( char[] and string[] ) Array.Find(arrayX, lambda expression) Returns the first element of arrayX that matches the condition defined in the lambda expression Array.Reverse(arrayX) Returns an array in which the elements are rearranged from last to first Array.Clear(arrayX) Returns an empty array (null or 0 as values), optionally define the range you want to clear (overload method) Documentation of all Array class properties and methods Accessing array elements As mentioned before, every element in the array has a position. We call this the index of the element. The first element has an index of 0, the second an index of 1, the third and index of 2... Example: Access the third element of the arrayOfStrings string thirdElement = arrayOfStrings[2]; Array editing Arrays are initialized to have a predefined length. this cannot be changed. However, the elements of the array can be changed as follows: arrayOfStrings[1] = \"newvalue\"; The second element of arrayOfStrings has now changed to \"newvalue\" overwriting the element that was there before. Printing an array Printing an array to the console does not print its contents. Instead you need to use the String.Join(string, string[]) method to concatenates all the elements of a string array ( string[] ), with a specific separator ( string ). Example: string[] nationalities = {\"belgian\", \"dutch\", \"german\", \"american\"}; Console.WriteLine(String.Join(\"\\n\", nationalities)); /* output will be: \"belgian\" \"dutch\" \"german\" \"american\"*/","title":"Arrays"},{"location":"9_data_structures_arrays/#arrays","text":"Arrays are data structures . Data structures store larger amounts of information in an organized way. An array is a linear list of elements of the same data type . Each element has a specific position in the list. Did you know : A string is an array of characters. You can ask for a character using its position in the string, just like you can do with arrays. Arrays Syntax Declaring an array Initializing an array Declaring and initializing an array An empty array Built-in properties and methods Accessing array elements Array editing Printing an array","title":"Arrays"},{"location":"9_data_structures_arrays/#syntax","text":"","title":"Syntax"},{"location":"9_data_structures_arrays/#declaring-an-array","text":"Declare an array by declaring its type followed by square brackets: string[] arrayOfStrings; int[] arrayOfInts; double[] arrayOfDoubles;","title":"Declaring an array"},{"location":"9_data_structures_arrays/#initializing-an-array","text":"Initialize an array by calling a new instance of the array class. The elements of the array are separated by commas and encapsulated in curly brackets: arrayOfStrings = new string[] {\"hallo\", \"beer\", \"kijken\"}; Note: We instantiating an object from the class Array, but the syntax deviates from the standard: use type[] instead of Array .","title":"Initializing an array"},{"location":"9_data_structures_arrays/#declaring-and-initializing-an-array","text":"You can also declare and initialize the array in one step, in that case you don't need to use the new type[] syntax: string[] arrayOfStrings = {\"hallo\", \"beer\", \"kijken\"};","title":"Declaring and initializing an array"},{"location":"9_data_structures_arrays/#an-empty-array","text":"What is you don't know yet what the content of your array will be? You can declare an empty array as follows: string[0] arrayOfStrings = new string[8]; This array has 8 strings This array now contains null values at every position Note: Empty arrays of strings contain null as values, empty arrays of integers contain 0 as values.","title":"An empty array"},{"location":"9_data_structures_arrays/#built-in-properties-and-methods","text":"Property /method Description arrayX.Length Returns the number of elements in the array Array.IndexOf(arrayX, valueX) Returns the index of valueX in arrayX Array.Sort(arrayX) Returns an array with the same elements as the input but in ascending order ( int[] , float[] ...), or alphabetical order ( char[] and string[] ) Array.Find(arrayX, lambda expression) Returns the first element of arrayX that matches the condition defined in the lambda expression Array.Reverse(arrayX) Returns an array in which the elements are rearranged from last to first Array.Clear(arrayX) Returns an empty array (null or 0 as values), optionally define the range you want to clear (overload method) Documentation of all Array class properties and methods","title":"Built-in properties and methods"},{"location":"9_data_structures_arrays/#accessing-array-elements","text":"As mentioned before, every element in the array has a position. We call this the index of the element. The first element has an index of 0, the second an index of 1, the third and index of 2... Example: Access the third element of the arrayOfStrings string thirdElement = arrayOfStrings[2];","title":"Accessing array elements"},{"location":"9_data_structures_arrays/#array-editing","text":"Arrays are initialized to have a predefined length. this cannot be changed. However, the elements of the array can be changed as follows: arrayOfStrings[1] = \"newvalue\"; The second element of arrayOfStrings has now changed to \"newvalue\" overwriting the element that was there before.","title":"Array editing"},{"location":"9_data_structures_arrays/#printing-an-array","text":"Printing an array to the console does not print its contents. Instead you need to use the String.Join(string, string[]) method to concatenates all the elements of a string array ( string[] ), with a specific separator ( string ). Example: string[] nationalities = {\"belgian\", \"dutch\", \"german\", \"american\"}; Console.WriteLine(String.Join(\"\\n\", nationalities)); /* output will be: \"belgian\" \"dutch\" \"german\" \"american\"*/","title":"Printing an array"}]}